/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0 
*PLEASE ENSURE THAT LEAN IS SET TO THIS VERSION, IF NOT COMPILATION WILL RESULT IN ERRORS.
*ONLINE LEAN COMPILERS WILL GIVE ERRORS, SINCE THEY ARE LIKELY ON THE LATEST LEAN VERSION.

Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 2615ef5d-f5a5-42d1-a1b9-6b3b3f5bde6d
To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We construct a sequence A satisfying the condition that the ratio of consecutive terms tends to 2, and for every cofinite subsequence A', the set of subset sums P(A') has asymptotic density 1. The construction is based on blocks of powers of 2 scaled by a rapidly growing sequence M_n. We prove the ratio limit and the density property using a greedy decomposition and a counting argument for the exceptions.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Nat.log2

/-
We define the sequence A by blocks.
k_n := 4 + ceil(log2(log2(n+16)))
M_0 := 10
M_{n+1} := floor((2^{k_n} - 1.5) * M_n)
Block n consists of M_n, 2M_n, ..., 2^{k_n-2}M_n, (2^{k_n-1}-1)M_n+1.
A is the concatenation of these blocks.
-/
def clog2 (n : ℕ) : ℕ :=
  if n ≤ 1 then 0 else (n - 1).log2 + 1

def k (n : ℕ) : ℕ :=
  4 + clog2 (clog2 (n + 16))

def M : ℕ → ℕ
| 0 => 10
| n + 1 => (M n * (2^(k n + 1) - 3)) / 2

def block (n : ℕ) : List ℕ :=
  (List.range (k n - 1)).map (fun i => 2^i * M n) ++ [(2^(k n - 1) - 1) * M n + 1]

def block_start : ℕ → ℕ
| 0 => 0
| n + 1 => block_start n + (block n).length

def A_val (n : ℕ) : ℕ :=
  let b_idx := Nat.find (p := fun m => n < block_start (m + 1)) (by
  -- Since $n$ is a natural number, we can choose $n_1 = n$.
  use n;
  -- We'll use that $block\_start (n + 1)$ is strictly increasing.
  have h_block_start_inc : StrictMono (fun n => block_start n) := by
    refine' strictMono_nat_of_lt_succ _;
    simp +arith +decide [ block_start ];
    unfold block; aesop;
  exact lt_of_lt_of_le ( Nat.lt_succ_self _ ) ( h_block_start_inc.id_le _ ))
  let inner_idx := n - block_start b_idx
  (block b_idx).get! inner_idx

/-
The set of finite subset sums of a sequence f.
-/
def subset_sums (f : ℕ → ℕ) : Set ℕ :=
  {s | ∃ (idx : Finset ℕ), s = ∑ i ∈ idx, f i}

/-
A set S has asymptotic density 1 if the limit of |S ∩ {0, ..., n-1}| / n as n -> infinity is 1.
-/
def has_asymptotic_density_one (S : Set ℕ) : Prop :=
  Filter.Tendsto (fun n => ((Finset.range n).filter (· ∈ S)).card / (n : ℝ)) Filter.atTop (nhds 1)

/-
The length of each block is positive.
-/
lemma block_length_pos (n : ℕ) : 0 < (block n).length := by
  unfold block; aesop;

/-
The start index of blocks is strictly increasing.
-/
lemma block_start_strict_mono : StrictMono block_start := by
  refine' strictMono_nat_of_lt_succ _;
  -- By definition of `block_start`, we have `block_start (n + 1) = block_start n + (block n).length`.
  have h_block_start_succ : ∀ n, block_start (n + 1) = block_start n + (block n).length := by
    aesop;
  exact fun n => h_block_start_succ n ▸ Nat.lt_add_of_pos_right ( block_length_pos n )

/-
M_n is always positive.
-/
lemma M_pos (n : ℕ) : 0 < M n := by
  induction' n with n ih;
  · decide +revert;
  · -- By definition of $M$, we have $M (n + 1) = \frac{M n \cdot (2^{k n + 1} - 3)}{2}$.
    have hM_succ : M (n + 1) = (M n * (2^(k n + 1) - 3)) / 2 := by
      rfl;
    refine' hM_succ.symm ▸ Nat.div_pos _ ( by decide );
    -- Since $k_n \geq 4$, we have $2^{k_n + 1} \geq 2^5 = 32$, thus $2^{k_n + 1} - 3 \geq 29$.
    have h_exp : 2^(k n + 1) - 3 ≥ 29 := by
      exact le_tsub_of_add_le_left ( by linarith [ Nat.pow_le_pow_right two_pos ( show k n + 1 ≥ 5 by linarith [ show k n ≥ 4 by exact le_add_of_nonneg_right ( Nat.zero_le _ ) ] ) ] );
    nlinarith

/-
M_n is nondecreasing.
-/
lemma M_mono : Monotone M := by
  refine' monotone_nat_of_le_succ _;
  intro n;
  refine Nat.le_div_iff_mul_le zero_lt_two |>.2 ?_;
  gcongr;
  exact le_tsub_of_add_le_left ( by linarith [ Nat.pow_le_pow_right two_pos ( show k n + 1 ≥ 3 by linarith [ show k n ≥ 2 by exact le_add_of_le_of_nonneg ( by norm_num ) ( Nat.zero_le _ ) ] ) ] )

/-
Each block is sorted in nondecreasing order.
-/
lemma block_sorted (n : ℕ) : (block n).Sorted (· ≤ ·) := by
  -- The first part of the block is sorted by definition.
  have h_first_part_sorted : List.Sorted (· ≤ ·) (List.map (fun i => 2^i * M n) (List.range (k n - 1))) := by
    norm_num [ List.Sorted ];
    norm_num [ List.pairwise_iff_get ];
    exact fun i j hij => Nat.mul_le_mul_right _ ( pow_le_pow_right₀ ( by decide ) hij.le );
  unfold block;
  simp_all +decide [ List.Sorted ];
  rcases u : k n - 1 with ( _ | _ | u ) <;> simp_all +decide [ List.pairwise_append ];
  exact fun a ha => Nat.le_succ_of_le ( Nat.mul_le_mul_right _ ( Nat.le_sub_one_of_lt ( pow_lt_pow_right₀ ( by decide ) ha ) ) )

/-
The last element of block n is less than or equal to the first element of block n+1.
-/
lemma M_transition_ineq (n : ℕ) : (2^(k n - 1) - 1) * M n + 1 ≤ M (n + 1) := by
  -- We'll use that $M_{n+1} = \left\lfloor \frac{2^{k_n + 1} - 3}{2} M_n \right\rfloor$.
  have h_M_succ : M (n + 1) ≥ (2^(k n + 1) - 3) * M n / 2 := by
    have h_M_succ : M (n + 1) = (M n * (2^(k n + 1) - 3)) / 2 := by
      exact?;
    rw [ h_M_succ, mul_comm ];
  rcases u : k n with ( _ | _ | k ) <;> simp_all +decide [ Nat.pow_succ', Nat.mul_succ ];
  · exact M_pos _;
  · exact Nat.one_le_iff_ne_zero.mpr ( ne_of_gt ( M_pos _ ) );
  · refine le_trans ?_ h_M_succ;
    exact Nat.le_div_iff_mul_le zero_lt_two |>.2 ( by nlinarith [ Nat.sub_add_cancel ( show 1 ≤ 2 * 2 ^ k from by linarith [ Nat.one_le_pow k 2 zero_lt_two ] ), Nat.sub_add_cancel ( show 3 ≤ 2 * ( 2 * ( 2 * 2 ^ k ) ) from by linarith [ Nat.one_le_pow k 2 zero_lt_two ] ), Nat.one_le_pow k 2 zero_lt_two, M_pos n ] )

/-
We define block_index(n) as the unique b such that block_start(b) <= n < block_start(b+1).
-/
def block_index (n : ℕ) : ℕ :=
  Nat.find (p := fun m => n < block_start (m + 1)) (by
  use n;
  induction' n with n ih <;> simp_all +decide [ block_start ];
  linarith [ block_length_pos ( n + 1 ) ])

/-
block_index(n) is the unique b such that block_start(b) <= n < block_start(b+1).
-/
lemma block_index_spec (n : ℕ) :
  block_start (block_index n) ≤ n ∧ n < block_start (block_index n + 1) := by
    apply And.intro;
    · have h_contra : ∀ m < block_index n, ¬(n < block_start (m + 1)) := by
        exact fun m mn => fun h => mn.not_le <| Nat.find_min' _ h;
      rcases m : block_index n with ( _ | _ | m ) <;> simp_all +decide;
      exact Nat.zero_le _;
    · exact Nat.find_spec ( _ : ∃ m, n < block_start ( m + 1 ) )

/-
The sequence A is nondecreasing.
-/
theorem A_is_nondecreasing : Monotone A_val := by
  -- To prove monotonicity, we show that for any $n$, $A_val(n) \leq A_val(n+1)$.
  have h_monotone : ∀ n, A_val n ≤ A_val (n + 1) := by
    -- Let $b_n = block\_index(n)$ and $b_{n+1} = block\_index(n+1)$.
    intro n
    set b_n := block_index n
    set b_n_plus_1 := block_index (n + 1);
    -- Since $n < n+1$, we have $b_n \le b_{n+1}$.
    have h_b_le : b_n ≤ b_n_plus_1 := by
      apply Nat.find_mono;
      exact fun m hm => Nat.lt_of_succ_lt hm;
    -- Consider two cases: $b_n = b_{n+1}$ and $b_n < b_{n+1}$.
    by_cases h_eq : b_n = b_n_plus_1;
    · -- Since $b_n = b_{n+1}$, we have $n$ and $n+1$ in the same block $b_n$.
      have h_block : n < block_start (b_n + 1) ∧ n + 1 < block_start (b_n + 1) := by
        have := block_index_spec n; have := block_index_spec ( n + 1 ) ; aesop;
      -- Since the block is sorted, the element at index $n - block_start(b_n)$ is less than or equal to the element at index $(n + 1) - block_start(b_n)$.
      have h_block_sorted : (block b_n).get! (n - block_start b_n) ≤ (block b_n).get! ((n + 1) - block_start b_n) := by
        have h_block_sorted : ∀ i j : ℕ, i < j → i < (block b_n).length → j < (block b_n).length → (block b_n).get! i ≤ (block b_n).get! j := by
          intros i j hij hi hj;
          have h_block_sorted : List.Pairwise (· ≤ ·) (block b_n) := by
            exact block_sorted b_n;
          have := List.pairwise_iff_get.mp h_block_sorted;
          simpa [ List.get?_eq_get, hi, hj ] using this ⟨ i, hi ⟩ ⟨ j, hj ⟩ hij;
        apply h_block_sorted;
        · rw [ tsub_lt_tsub_iff_right ] <;> linarith [ block_index_spec n ];
        · rw [ tsub_lt_iff_left ];
          · convert h_block.1 using 1;
          · exact block_index_spec n |>.1;
        · rw [ tsub_lt_iff_left ];
          · convert h_block.2 using 1;
          · exact Nat.le_succ_of_le ( block_index_spec n |>.1 );
      convert h_block_sorted using 1;
      unfold A_val; aesop;
    · -- Since $b_n < b_{n+1}$, we have $n$ is the last element of block $b_n$ and $n+1$ is the first element of block $b_n+1$.
      have h_last_first : n = block_start b_n + (block b_n).length - 1 ∧ n + 1 = block_start (b_n + 1) := by
        have h_last_first : n < block_start (b_n + 1) ∧ n + 1 ≥ block_start (b_n + 1) := by
          have h_last_first : n < block_start (b_n + 1) ∧ n + 1 ≥ block_start (b_n_plus_1) := by
            exact ⟨ Nat.find_spec ( _ : ∃ m, n < block_start ( m + 1 ) ), Nat.le_of_lt_succ <| by linarith [ block_index_spec n, block_index_spec ( n + 1 ) ] ⟩;
          exact ⟨ h_last_first.1, h_last_first.2.trans' ( block_start_strict_mono.monotone ( Nat.succ_le_of_lt ( lt_of_le_of_ne h_b_le h_eq ) ) ) ⟩;
        have h_last_first : block_start (b_n + 1) = block_start b_n + (block b_n).length := by
          exact?;
        omega;
      -- By definition of $A_val$, we have $A_val(n) = (2^{k_{b_n}-1}-1)M_{b_n}+1$ and $A_val(n+1) = M_{b_n+1}$.
      have h_A_val_n : A_val n = (2^(k b_n - 1) - 1) * M b_n + 1 := by
        -- By definition of $A_val$, we have $A_val(n) = (block b_n).get! ((block b_n).length - 1)$.
        have h_A_val_n_def : A_val n = (block b_n).get! ((block b_n).length - 1) := by
          -- By definition of $A_val$, we have $A_val(n) = (block b_n).get! (n - block_start b_n)$.
          have h_A_val_n_def : A_val n = (block b_n).get! (n - block_start b_n) := by
            exact?;
          rw [ h_A_val_n_def, show n - block_start b_n = ( block b_n |> List.length ) - 1 from by omega ];
        rw [ h_A_val_n_def ];
        unfold block; simp +decide [ List.get! ] ;
      have h_A_val_n_plus_1 : A_val (n + 1) = M (b_n + 1) := by
        -- By definition of $A_val$, we have $A_val(n+1) = M_{b_n+1}$.
        have h_A_val_n_plus_1 : A_val (n + 1) = (block (b_n + 1)).get! 0 := by
          rw [ show n + 1 = block_start ( b_n + 1 ) from h_last_first.2 ];
          unfold A_val; simp +decide [ block_index_spec ] ;
          rw [ show Nat.find ( show ∃ m, block_start ( m + 1 ) > block_start ( b_n + 1 ) from ⟨ b_n + 1, by linarith [ block_start_strict_mono ( Nat.lt_succ_self ( b_n + 1 ) ) ] ⟩ ) = b_n + 1 from _ ];
          · norm_num;
          · rw [ Nat.find_eq_iff ];
            exact ⟨ block_start_strict_mono ( Nat.lt_succ_self _ ), fun n hn => not_lt_of_ge ( block_start_strict_mono.monotone ( by linarith ) ) ⟩;
        rcases x : k ( block_index n + 1 ) with ( _ | _ | k ) <;> simp +decide [ x ] at h_A_val_n_plus_1 ⊢;
        · unfold k at x; simp +decide [ Nat.log2 ] at x;
        · unfold k at x; norm_num at x;
          omega;
        · unfold block at h_A_val_n_plus_1; simp +decide [ x ] at h_A_val_n_plus_1 ⊢;
          grind;
      exact h_A_val_n.symm ▸ h_A_val_n_plus_1.symm ▸ M_transition_ineq _;
  exact monotone_nat_of_le_succ h_monotone

/-
For i < k_n - 2, the ratio of the (i+1)-th and i-th elements of block n is exactly 2.
-/
lemma block_ratio_exact (n i : ℕ) (h : i < k n - 2) :
  ((block n).get! (i + 1) : ℝ) / (block n).get! i = 2 := by
    -- The block is constructed as a list where each element is 2^i * M n for i from 0 to k n - 2, and the last element is (2^(k n - 1) - 1) * M n + 1.
    have h_block : block n = List.map (fun i => 2^i * M n) (List.range (k n - 1)) ++ [(2^(k n - 1) - 1) * M n + 1] := by
      exact?;
    rcases k : k n with ( _ | _ | k ) <;> simp_all +decide [ Nat.pow_succ', mul_assoc ];
    simp_all +decide [ List.getElem?_append, List.getElem?_range ];
    rw [ if_pos ( by linarith ), div_eq_iff ] <;> norm_cast <;> norm_num [ pow_succ', Nat.mul_assoc ];
    exact ne_of_gt ( M_pos _ )

/-
The ratio of the last two elements of block n tends to 2 as n -> infinity.
-/
lemma block_ratio_last :
  Filter.Tendsto (fun n => (((2^(k n - 1) - 1) * M n + 1 : ℕ) : ℝ) / ((2^(k n - 2) * M n : ℕ) : ℝ)) Filter.atTop (nhds (2 : ℝ)) := by
    -- Simplify the expression inside the limit.
    suffices h_simp : Filter.Tendsto (fun n => (2 - 1 / 2^(k n - 2) + 1 / (2^(k n - 2) * M n) : ℝ)) Filter.atTop (nhds 2) by
      refine h_simp.congr' ?_ ; filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn ; rcases k_n : k n with ( _ | _ | k ) <;> simp_all +decide [ pow_succ', mul_assoc, div_eq_mul_inv ] ; ring;
      · unfold k at k_n ; aesop;
      · unfold k at k_n;
        omega;
      · field_simp
        ring;
        rw [ mul_inv_cancel₀ ( Nat.cast_ne_zero.mpr <| ne_of_gt <| M_pos n ) ] ; ring;
    -- We need to show that $2^{k_n - 2}$ tends to infinity as $n$ tends to infinity.
    have h_exp : Filter.Tendsto (fun n => (2 : ℝ) ^ (k n - 2)) Filter.atTop Filter.atTop := by
      -- Since $k_n$ tends to infinity, $k_n - 2$ also tends to infinity.
      have h_k_inf : Filter.Tendsto k Filter.atTop Filter.atTop := by
        -- Since $clog2$ and $log2$ are both increasing functions, it follows that $k_n$ tends to infinity as $n$ tends to infinity.
        have h_log_log_inf : Filter.Tendsto (fun n => clog2 (clog2 (n + 16))) Filter.atTop Filter.atTop := by
          -- The function $clog2$ is the ceiling of the logarithm base 2, which tends to infinity as its argument tends to infinity.
          have h_log_base2_inf : Filter.Tendsto (fun n => Nat.log2 (n + 16)) Filter.atTop Filter.atTop := by
            rw [ Filter.tendsto_atTop_atTop ];
            intro b; use 2^b; intro a ha; rw [ Nat.le_log2 ] <;> linarith [ Nat.pow_le_pow_right two_pos b.zero_le ] ;
          -- Since $clog2$ is the ceiling of the logarithm base 2, and we know that $Nat.log2$ tends to infinity, it follows that $clog2$ also tends to infinity.
          have h_clog2_inf : Filter.Tendsto (fun n => clog2 n) Filter.atTop Filter.atTop := by
            have h_clog2_inf : Filter.Tendsto (fun n => Nat.log2 (n - 1) + 1) Filter.atTop Filter.atTop := by
              rw [ Filter.tendsto_atTop_atTop ] at *;
              intro b; obtain ⟨ i, hi ⟩ := h_log_base2_inf b; use i + 17; intros a ha; specialize hi ( a - 17 ) ( Nat.le_sub_of_add_le ( by linarith ) ) ; rcases a with ( _ | _ | a ) <;> simp_all +arith +decide;
              grind;
            exact h_clog2_inf.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 1 ] with n hn; rw [ clog2 ] ; aesop );
          exact h_clog2_inf.comp ( h_clog2_inf.comp ( Filter.tendsto_add_atTop_nat 16 ) );
        exact Filter.tendsto_atTop_mono ( fun n => Nat.le_add_left _ _ ) h_log_log_inf;
      exact tendsto_pow_atTop_atTop_of_one_lt one_lt_two |> Filter.Tendsto.comp <| Filter.tendsto_atTop_atTop.mpr fun x => by rcases Filter.eventually_atTop.mp ( h_k_inf.eventually_ge_atTop ( x + 2 ) ) with ⟨ n, hn ⟩ ; exact ⟨ n, fun m hm => Nat.le_sub_of_add_le <| by linarith [ hn m hm ] ⟩ ;
    exact le_trans ( Filter.Tendsto.add ( tendsto_const_nhds.sub ( tendsto_const_nhds.div_atTop <| h_exp ) ) ( tendsto_const_nhds.div_atTop <| Filter.tendsto_atTop_atTop.mpr fun x => by rcases Filter.eventually_atTop.mp ( h_exp.eventually_ge_atTop ( ⌈x⌉₊ + 1 : ℝ ) ) with ⟨ n, hn ⟩ ; exact ⟨ n, fun m hm => by nlinarith [ Nat.le_ceil x, show ( M m : ℝ ) ≥ 1 by exact_mod_cast M_pos m, hn m hm ] ⟩ ) ) ( by norm_num )

/-
The ratio of the first element of block n+1 to the last element of block n tends to 2.
-/
lemma block_ratio_cross :
  Filter.Tendsto (fun n => (M (n + 1) : ℝ) / ((2^(k n - 1) - 1) * M n + 1)) Filter.atTop (nhds 2) := by
    -- First, note that $M_{n+1} = \lfloor (2^{k_n} - 1.5) M_n \rfloor$, so for large $n$, $M_{n+1} \approx (2^{k_n} - 1.5) M_n$.
    have h_M_approx : Filter.Tendsto (fun n => ((M (n + 1) : ℝ) / (M n * (2 ^ (k n) - 1.5)))) Filter.atTop (nhds 1) := by
      -- By definition of $M$, we know that $M (n + 1) = \lfloor (2^{k n} - 1.5) * M n \rfloor$.
      have h_M_succ : ∀ n, M (n + 1) = Nat.floor ((2^(k n) - 1.5 : ℝ) * M n) := by
        intro n;
        -- By definition of $M$, we know that $M (n + 1) = \lfloor (2^{k n} - 1.5) * M n \rfloor$ follows directly from the recursive definition of $M$.
        have h_M_succ : M (n + 1) = Nat.floor ((2^(k n + 1) - 3) * M n / 2 : ℝ) := by
          rw [ eq_comm, Nat.floor_eq_iff ];
          · rw [ le_div_iff₀, div_lt_iff₀ ] <;> norm_cast;
            rw [ Int.subNatNat_of_le ] <;> norm_cast;
            · exact ⟨ Nat.le_of_lt_succ <| by linarith! [ Nat.div_mul_le_self ( M n * ( 2 ^ ( k n + 1 ) - 3 ) ) 2 ], by linarith! [ Nat.div_add_mod ( M n * ( 2 ^ ( k n + 1 ) - 3 ) ) 2, Nat.mod_lt ( M n * ( 2 ^ ( k n + 1 ) - 3 ) ) two_pos ] ⟩;
            · exact le_trans ( by decide ) ( Nat.pow_le_pow_right ( by decide ) ( Nat.succ_le_succ ( show k n ≥ 1 from Nat.succ_le_of_lt ( Nat.pos_of_ne_zero ( by unfold k; aesop ) ) ) ) );
          · exact div_nonneg ( mul_nonneg ( sub_nonneg_of_le ( by norm_cast; linarith [ Nat.pow_le_pow_right two_pos ( show k n + 1 ≥ 2 by linarith [ show k n ≥ 1 from Nat.one_le_iff_ne_zero.mpr ( by unfold k; aesop ) ] ) ] ) ) ( Nat.cast_nonneg _ ) ) zero_le_two;
        convert h_M_succ using 2 ; ring;
      -- Since $M_n$ is nondecreasing and tends to infinity, the term $1/(M_n * (2^{k_n} - 1.5))$ tends to 0.
      have h_term_zero : Filter.Tendsto (fun n => 1 / ((M n : ℝ) * (2 ^ (k n) - 1.5))) Filter.atTop (nhds 0) := by
        -- Since $k_n \geq 4$, we have $2^{k_n} - 1.5 \geq 2^4 - 1.5 = 14.5$.
        have h_lower_bound : ∀ n, (2^(k n) - 1.5 : ℝ) ≥ 14.5 := by
          intro n; norm_num; linarith [ pow_le_pow_right₀ ( by norm_num : ( 1 : ℝ ) ≤ 2 ) ( show k n ≥ 4 by exact le_add_of_le_of_nonneg ( by norm_num ) ( Nat.zero_le _ ) ) ] ;
        -- Since $M_n$ is nondecreasing and tends to infinity, the term $M_n$ tends to infinity.
        have h_M_inf : Filter.Tendsto (fun n => (M n : ℝ)) Filter.atTop Filter.atTop := by
          -- By definition of $M$, we know that $M_{n+1} \geq 2 * M_n$.
          have h_M_lower_bound : ∀ n, (M (n + 1) : ℝ) ≥ 2 * (M n : ℝ) := by
            intro n; rw [ h_M_succ ] ; exact_mod_cast Nat.le_floor <| by norm_num; nlinarith [ h_lower_bound n, show ( M n : ℝ ) ≥ 1 by exact_mod_cast M_pos n ] ;
          -- By induction, we can show that $M_n \geq 2^n$.
          have h_M_ge_pow : ∀ n, (M n : ℝ) ≥ 2^n := by
            exact fun n => Nat.recOn n ( by norm_num [ show M 0 = 10 by rfl ] ) fun n ih => by rw [ pow_succ' ] ; linarith [ h_M_lower_bound n ] ;
          exact Filter.tendsto_atTop_mono h_M_ge_pow ( tendsto_pow_atTop_atTop_of_one_lt one_lt_two );
        exact tendsto_const_nhds.div_atTop ( Filter.tendsto_atTop_mono ( fun n => by nlinarith [ h_lower_bound n ] ) h_M_inf );
      have h_floor_approx : ∀ n, abs ((M (n + 1) : ℝ) / ((M n : ℝ) * (2 ^ (k n) - 1.5)) - 1) ≤ 1 / ((M n : ℝ) * (2 ^ (k n) - 1.5)) := by
        intro n; rw [ h_M_succ ] ; rw [ abs_le ] ; constructor <;> norm_num;
        · field_simp;
          rw [ le_div_iff₀ ] <;> nlinarith [ Nat.lt_floor_add_one ( ( 2 ^ k n * 2 - 3 ) * ( M n : ℝ ) / 2 ), show ( 2 ^ k n * 2 - 3 : ℝ ) * ( M n : ℝ ) > 0 from mul_pos ( sub_pos.mpr <| by nlinarith [ show ( 2 : ℝ ) ^ k n ≥ 2 by exact le_trans ( by norm_num ) <| pow_le_pow_right₀ ( by norm_num ) <| show k n ≥ 1 from Nat.one_le_iff_ne_zero.mpr <| by { exact ne_of_gt <| Nat.pos_of_ne_zero <| by { unfold k; aesop } } ] ) <| Nat.cast_pos.mpr <| M_pos n ];
        · rw [ ← mul_inv, div_le_iff₀ ] <;> norm_num;
          · rw [ inv_mul_eq_div, div_add_one, div_mul_eq_mul_div, le_div_iff₀ ] <;> norm_num;
            · nlinarith [ Nat.floor_le ( show 0 ≤ ( 2 ^ k n - 3 / 2 : ℝ ) * M n by exact mul_nonneg ( sub_nonneg_of_le ( by exact le_trans ( by norm_num ) ( pow_le_pow_right₀ ( by norm_num ) ( show k n ≥ 2 by exact le_add_of_le_of_nonneg ( by norm_num ) ( Nat.zero_le _ ) ) ) ) ) ( Nat.cast_nonneg _ ) ), inv_mul_cancel₀ ( show ( 2 ^ k n - 3 / 2 : ℝ ) ≠ 0 by exact ne_of_gt ( sub_pos_of_lt ( by exact lt_of_lt_of_le ( by norm_num ) ( pow_le_pow_right₀ ( by norm_num ) ( show k n ≥ 2 by exact le_add_of_le_of_nonneg ( by norm_num ) ( Nat.zero_le _ ) ) ) ) ) ) ];
            · exact?;
            · exact ne_of_gt ( M_pos n );
          · exact mul_pos ( Nat.cast_pos.mpr ( M_pos n ) ) ( sub_pos.mpr ( lt_of_lt_of_le ( by norm_num ) ( pow_le_pow_right₀ ( by norm_num ) ( show k n ≥ 2 by exact le_add_of_le_of_nonneg ( by norm_num ) ( Nat.zero_le _ ) ) ) ) );
      exact tendsto_iff_norm_sub_tendsto_zero.mpr ( squeeze_zero ( fun _ => abs_nonneg _ ) h_floor_approx h_term_zero );
    -- Now consider the ratio $\frac{(2^{k_n} - 1.5) M_n}{(2^{k_n - 1} - 1) M_n + 1}$.
    have h_ratio : Filter.Tendsto (fun n => ((2 ^ (k n) - 1.5) * (M n : ℝ)) / ((2 ^ (k n - 1) - 1) * (M n : ℝ) + 1)) Filter.atTop (nhds 2) := by
      -- We can divide the numerator and the denominator by $M_n$.
      have h_div : Filter.Tendsto (fun n => ((2 ^ (k n) - 1.5) : ℝ) / ((2 ^ (k n - 1) - 1) + 1 / (M n : ℝ))) Filter.atTop (nhds 2) := by
        -- We'll use the fact that $k_n \to \infty$ as $n \to \infty$.
        have h_k_inf : Filter.Tendsto k Filter.atTop Filter.atTop := by
          -- Since $clog2$ is non-decreasing and $n + 16$ grows without bound, $clog2 (clog2 (n + 16))$ also grows without bound.
          have h_clog2_growth : Filter.Tendsto (fun n => clog2 (clog2 (n + 16))) Filter.atTop Filter.atTop := by
            have h_clog2_growth : Filter.Tendsto (fun n => clog2 n) Filter.atTop Filter.atTop := by
              unfold clog2;
              rw [ Filter.tendsto_atTop_atTop ];
              intro b; use 2 ^ b + 2; intro a ha; split_ifs <;> norm_num at *;
              · linarith [ Nat.one_le_pow b 2 zero_lt_two ];
              · rw [ Nat.le_iff_lt_or_eq ];
                refine' lt_or_eq_of_le ( Nat.le_succ_of_le _ );
                rw [ Nat.le_log2 ] <;> omega;
            exact h_clog2_growth.comp <| h_clog2_growth.comp <| Filter.tendsto_add_atTop_nat 16;
          exact Filter.tendsto_atTop_mono ( fun n => Nat.le_add_left _ _ ) h_clog2_growth;
        -- We can divide the numerator and the denominator by $2^{k_n}$.
        have h_divide : Filter.Tendsto (fun n => ((1 - 1.5 / (2 ^ (k n) : ℝ)) / ((1 / 2) - 1 / (2 ^ (k n) : ℝ) + 1 / (M n * 2 ^ (k n) : ℝ)))) Filter.atTop (nhds 2) := by
          -- As $n \to \infty$, $1 / 2^{k_n} \to 0$ and $1 / (M_n * 2^{k_n}) \to 0$.
          have h_zero : Filter.Tendsto (fun n => 1 / (2 ^ (k n) : ℝ)) Filter.atTop (nhds 0) ∧ Filter.Tendsto (fun n => 1 / (M n * 2 ^ (k n) : ℝ)) Filter.atTop (nhds 0) := by
            norm_num +zetaDelta at *;
            exact ⟨ tendsto_inv_atTop_zero.comp <| tendsto_pow_atTop_atTop_of_one_lt one_lt_two |> Filter.Tendsto.comp <| h_k_inf, squeeze_zero ( fun _ => by positivity ) ( fun n => mul_le_of_le_one_right ( by positivity ) <| inv_le_one_of_one_le₀ <| mod_cast Nat.one_le_iff_ne_zero.mpr <| ne_of_gt <| M_pos _ ) <| tendsto_inv_atTop_zero.comp <| tendsto_pow_atTop_atTop_of_one_lt one_lt_two |> Filter.Tendsto.comp <| h_k_inf ⟩;
          convert Filter.Tendsto.div ( tendsto_const_nhds.sub ( tendsto_const_nhds.div_atTop ( tendsto_pow_atTop_atTop_of_one_lt one_lt_two |> Filter.Tendsto.comp <| h_k_inf ) ) ) ( Filter.Tendsto.add ( tendsto_const_nhds.sub ( h_zero.1 ) ) h_zero.2 ) _ using 2 <;> norm_num;
        refine h_divide.congr' ?_;
        filter_upwards [ h_k_inf.eventually_gt_atTop 0 ] with n hn;
        field_simp [hn];
        rw [ show ( 2 ^ k n - 2 + 2 / ( M n : ℝ ) ) = ( 2 ^ ( k n - 1 ) - 1 + 1 / ( M n : ℝ ) ) * 2 by cases k_n : k n <;> norm_num [ pow_succ', k_n ] at * ; ring ] ; rw [ mul_div_mul_right _ _ ( by positivity ) ];
      refine h_div.congr' ?_;
      filter_upwards [ h_M_approx.eventually_ne one_ne_zero ] with n hn;
      grind;
    have := h_M_approx.mul h_ratio;
    convert this using 2 <;> norm_num;
    field_simp;
    rw [ ← mul_div_mul_right _ _ ( show ( M ‹_› : ℝ ) * ( 2 ^ k ‹_› * 2 - 3 ) ≠ 0 from mul_ne_zero ( Nat.cast_ne_zero.mpr <| ne_of_gt <| M_pos _ ) <| sub_ne_zero.mpr <| by norm_cast; linarith [ Nat.pow_le_pow_right two_pos <| show k ‹_› ≥ 1 from Nat.one_le_iff_ne_zero.mpr <| by { unfold k; aesop } ] ) ] ; ring

/-
The ratio of consecutive terms of the sequence A tends to 2.
-/
theorem A_ratio_limit : Filter.Tendsto (fun n => (A_val (n + 1) : ℝ) / A_val n) Filter.atTop (nhds 2) := by
  -- Let $b_n$ be the block index of $n$. There are three cases for the position of $n$ within block $b_n$:
  have h_cases : ∀ n, block_index (n + 1) = block_index n ∨ block_index (n + 1) = block_index n + 1 := by
    intro n
    have h_block_index_succ : block_index (n + 1) ≤ block_index n + 1 := by
      refine' Nat.find_min' _ _;
      exact lt_of_le_of_lt ( Nat.succ_le_of_lt ( block_index_spec n |>.2 ) ) ( by exact strictMono_nat_of_lt_succ ( fun m => by exact ( show block_start ( m + 1 ) > block_start m from by { exact Nat.lt_of_le_of_lt ( by norm_num ) ( block_start_strict_mono ( Nat.lt_succ_self _ ) ) } ) ) ( Nat.lt_succ_self _ ) )
    have h_block_index_ge : block_index (n + 1) ≥ block_index n := by
      unfold block_index;
      simp +zetaDelta at *;
      exact fun m hm => Nat.le_succ_of_le ( hm m le_rfl )
    exact Classical.or_iff_not_imp_left.2 fun h => le_antisymm h_block_index_succ (lt_of_le_of_ne h_block_index_ge (Ne.symm h));
  -- Let's consider the three cases from `h_cases`.
  have h_case1 : Filter.Tendsto (fun n => ((A_val (n + 1)) : ℝ) / ((A_val n) : ℝ)) Filter.atTop (nhds 2) := by
    have h_case1_aux : ∀ n, block_index (n + 1) = block_index n → ((A_val (n + 1)) : ℝ) / ((A_val n) : ℝ) = 2 ∨ ((A_val (n + 1)) : ℝ) / ((A_val n) : ℝ) = ((2^(k (block_index n) - 1) - 1) * M (block_index n) + 1 : ℝ) / ((2^(k (block_index n) - 2) * M (block_index n) : ℝ)) := by
      intro n hn
      have h_block : A_val n = (block (block_index n)).get! (n - block_start (block_index n)) ∧ A_val (n + 1) = (block (block_index n)).get! (n + 1 - block_start (block_index n)) := by
        unfold A_val;
        unfold block_index at * ; aesop;
      have h_pos : n - block_start (block_index n) < k (block_index n) - 1 := by
        have h_pos : n + 1 < block_start (block_index n + 1) := by
          have := block_index_spec ( n + 1 ) ; aesop;
        rw [ tsub_lt_iff_left ];
        · have h_pos : block_start (block_index n + 1) = block_start (block_index n) + (block (block_index n)).length := by
            exact?;
          simp_all +decide [ block ];
          linarith;
        · exact Nat.le_of_lt_succ ( by linarith [ block_index_spec n ] );
      by_cases h_last : n - block_start (block_index n) = k (block_index n) - 2;
      · rcases x : k ( block_index n ) with ( _ | _ | k ) <;> simp_all +decide [ Nat.pow_succ', Nat.mul_succ ];
        simp_all +decide [ Nat.sub_add_comm ( show block_start ( block_index n ) ≤ n from Nat.le_of_lt_succ <| by linarith [ Nat.sub_add_cancel <| show block_start ( block_index n ) ≤ n from Nat.le_of_lt_succ <| by linarith [ Nat.sub_add_cancel <| show block_start ( block_index n ) ≤ n from Nat.le_of_lt_succ <| by linarith [ block_index_spec n ] ] ] ) ];
        rw [ show ( block ( block_index n ) ) = ( List.range ( k + 1 ) ).map ( fun i => 2 ^ i * M ( block_index n ) ) ++ [ ( 2 ^ ( k + 1 ) - 1 ) * M ( block_index n ) + 1 ] from ?_ ];
        · simp +decide [ List.getElem?_append, List.getElem?_range ];
        · unfold block; aesop;
      · have h_ratio : ((block (block_index n)).get! (n + 1 - block_start (block_index n)) : ℝ) / ((block (block_index n)).get! (n - block_start (block_index n)) : ℝ) = 2 := by
          convert block_ratio_exact ( block_index n ) ( n - block_start ( block_index n ) ) _ using 1;
          · rw [ Nat.sub_add_comm ( show block_start ( block_index n ) ≤ n from by linarith [ block_index_spec n ] ) ];
          · omega;
        aesop
    have h_case2_aux : ∀ n, block_index (n + 1) = block_index n + 1 → ((A_val (n + 1)) : ℝ) / ((A_val n) : ℝ) = (M (block_index n + 1) : ℝ) / ((2^(k (block_index n) - 1) - 1) * M (block_index n) + 1) := by
      intro n hn
      have h_last : A_val n = (2^(k (block_index n) - 1) - 1) * M (block_index n) + 1 := by
        have h_last : n = block_start (block_index n) + (block (block_index n)).length - 1 := by
          have h_last : n < block_start (block_index n + 1) ∧ block_start (block_index n + 1) = block_start (block_index n) + (block (block_index n)).length := by
            exact ⟨ block_index_spec n |>.2, rfl ⟩;
          have h_last : n + 1 = block_start (block_index n + 1) := by
            have h_last : block_start (block_index n + 1) ≤ n + 1 := by
              have := block_index_spec ( n + 1 ) ; aesop;
            grind;
          exact eq_tsub_of_add_eq <| by linarith;
        rw [ show A_val n = ( block ( block_index n ) |> List.get! ) ( n - block_start ( block_index n ) ) from ?_ ];
        · rw [ show n - block_start ( block_index n ) = ( block ( block_index n ) |> List.length ) - 1 from ?_ ];
          · unfold block; norm_num;
          · omega;
        · exact?
      have h_first : A_val (n + 1) = M (block_index n + 1) := by
        have h_first : A_val (n + 1) = (block (block_index n + 1)).get! 0 := by
          have h_first : A_val (n + 1) = (block (block_index (n + 1))).get! (n + 1 - block_start (block_index (n + 1))) := by
            exact?;
          simp_all +decide [ Nat.sub_sub ];
          rw [ show n + 1 - block_start ( block_index n + 1 ) = 0 from Nat.sub_eq_zero_of_le <| by linarith [ block_index_spec n, block_index_spec ( n + 1 ) ] ];
        rcases k : k ( block_index n + 1 ) with ( _ | _ | k ) <;> simp_all +decide [ List.get! ];
        · unfold _root_.k at k; aesop;
        · unfold _root_.k at k;
          omega;
        · unfold block; aesop;
      rw [h_last, h_first];
      norm_num [ Nat.cast_sub ( Nat.one_le_pow _ _ zero_lt_two ) ];
    -- By combining the results from `h_case1_aux` and `h_case2_aux`, we can conclude that the limit of the ratio is 2.
    have h_limit : Filter.Tendsto (fun n => ((2^(k (block_index n) - 1) - 1) * M (block_index n) + 1 : ℝ) / ((2^(k (block_index n) - 2) * M (block_index n) : ℝ))) Filter.atTop (nhds 2) ∧ Filter.Tendsto (fun n => (M (block_index n + 1) : ℝ) / ((2^(k (block_index n) - 1) - 1) * M (block_index n) + 1)) Filter.atTop (nhds 2) := by
      constructor;
      · have h_case1_limit : Filter.Tendsto (fun n => ((2^(k n - 1) - 1) * M n + 1 : ℝ) / ((2^(k n - 2) * M n : ℝ))) Filter.atTop (nhds 2) := by
          convert block_ratio_last using 1;
          norm_num [ Nat.cast_sub ( show 1 ≤ 2 ^ ( k _ - 1 ) from Nat.one_le_pow _ _ ( by decide ) ) ];
        refine h_case1_limit.comp ?_;
        refine' Filter.tendsto_atTop_atTop.mpr _;
        intro b; use block_start b; intro a ha; exact (by
        contrapose! ha;
        exact lt_of_lt_of_le ( block_index_spec a |>.2 ) ( Nat.le_induction ( by norm_num ) ( fun n hn ih => by linarith [ block_start_strict_mono n.lt_succ_self ] ) _ ha ));
      · have h_limit : Filter.Tendsto (fun n => (M (n + 1) : ℝ) / ((2^(k n - 1) - 1) * M n + 1)) Filter.atTop (nhds 2) := by
          convert block_ratio_cross using 1;
        refine h_limit.comp <| Filter.tendsto_atTop_atTop.mpr ?_;
        intro b; use block_start b; intro n hn; exact (by
        contrapose! hn;
        refine' lt_of_lt_of_le ( block_index_spec n |>.2 ) _;
        exact monotone_nat_of_le_succ ( fun n => by exact Nat.le_add_right _ _ ) hn);
    rw [ Metric.tendsto_nhds ] at *;
    intro ε hε;
    simp +zetaDelta at *;
    obtain ⟨ a, ha ⟩ := h_limit.1 ε hε;
    obtain ⟨ b, hb ⟩ := Metric.tendsto_atTop.mp h_limit.2 ε hε;
    exact ⟨ Max.max a b, fun n hn => by cases h_cases n <;> [ exact Or.casesOn ( h_case1_aux n ‹_› ) ( fun h => by simpa [ h ] using hε ) fun h => by simpa [ h ] using ha n ( le_trans ( le_max_left _ _ ) hn ) ; ; exact by simpa [ h_case2_aux n ‹_› ] using hb n ( le_trans ( le_max_right _ _ ) hn ) ] ⟩;
  convert h_case1 using 1

/-
We define the digit sets B_n.
B_n = {j * M_n | 0 <= j <= 2^{k_n-1}-1} U {j * M_n + 1 | 2^{k_n-1} <= j <= 2^{k_n}-2}.
-/
def B (n : ℕ) : Set ℕ :=
  {x | ∃ j, (j ≤ 2^(k n - 1) - 1 ∧ x = j * M n) ∨
            (2^(k n - 1) ≤ j ∧ j ≤ 2^(k n) - 2 ∧ x = j * M n + 1)}

/-
For every x in [0, M_{n+1}] there exists b in B_n such that 0 <= x - b <= M_n.
-/
lemma greedy_covering (n : ℕ) (x : ℕ) (hx : x ≤ M (n + 1)) :
  ∃ b ∈ B n, x - b ≤ M n ∧ b ≤ x := by
    by_cases hx' : x ≤ ( 2 ^ ( k n - 1 ) - 1 ) * M n;
    · refine' ⟨ ⌊x / M n⌋₊ * M n, _, _, _ ⟩;
      · exact ⟨ Nat.floor ( x / M n ), Or.inl ⟨ Nat.le_sub_one_of_lt ( Nat.div_lt_of_lt_mul <| by nlinarith [ Nat.sub_add_cancel ( Nat.one_le_pow ( k n - 1 ) 2 zero_lt_two ), M_pos n ] ), rfl ⟩ ⟩;
      · exact Nat.sub_le_of_le_add <| by nlinarith [ Nat.div_add_mod x ( M n ), Nat.mod_lt x ( show M n > 0 from M_pos n ), show ⌊x / M n⌋₊ ≥ x / M n from Nat.le_ceil _ ] ;
      · exact Nat.div_mul_le_self _ _;
    · by_cases hx'' : x ≤ (2^(k n - 1) * M n);
      · refine' ⟨ ( 2 ^ ( k n - 1 ) - 1 ) * M n, _, _, _ ⟩ <;> norm_num;
        · exact ⟨ 2 ^ ( k n - 1 ) - 1, Or.inl ⟨ by omega, rfl ⟩ ⟩;
        · nlinarith [ Nat.sub_add_cancel ( Nat.one_le_pow ( k n - 1 ) 2 zero_lt_two ) ];
        · grind;
      · -- If $x > 2^{k_n-1}M_n$, we can find $b \in B_n$ such that $b \leq x < b'$, where $b'$ is the next element in $B_n$.
        obtain ⟨b, hb⟩ : ∃ b ∈ B n, b ≤ x ∧ x < b + M n + 1 := by
          -- Let $b = j * M n + 1$ where $j$ is the largest integer such that $j * M n + 1 \leq x$.
          obtain ⟨j, hj⟩ : ∃ j, j * M n + 1 ≤ x ∧ x < (j + 1) * M n + 1 := by
            exact ⟨ ( x - 1 ) / M n, by linarith [ Nat.div_mul_le_self ( x - 1 ) ( M n ), Nat.sub_add_cancel ( show 1 ≤ x from Nat.pos_of_ne_zero ( by aesop_cat ) ) ], by linarith [ Nat.div_add_mod ( x - 1 ) ( M n ), Nat.mod_lt ( x - 1 ) ( show M n > 0 from M_pos n ), Nat.sub_add_cancel ( show 1 ≤ x from Nat.pos_of_ne_zero ( by aesop_cat ) ) ] ⟩;
          use j * M n + 1;
          refine' ⟨ _, hj.1, by linarith ⟩;
          refine' ⟨ j, Or.inr ⟨ _, _, rfl ⟩ ⟩;
          · nlinarith [ Nat.sub_add_cancel ( Nat.one_le_pow ( k n - 1 ) 2 zero_lt_two ) ];
          · -- By definition of $M$, we know that $M (n + 1) \leq (2^{k n} - 1.5) * M n$.
            have hM_succ : M (n + 1) ≤ (2^(k n) - 1) * M n := by
              rw [ Nat.mul_comm ];
              refine' Nat.div_le_of_le_mul _;
              rw [ mul_left_comm, Nat.pow_succ' ];
              exact Nat.mul_le_mul_left _ ( by omega );
            nlinarith [ Nat.sub_add_cancel ( show 1 ≤ 2 ^ k n from Nat.one_le_pow _ _ ( by decide ) ), Nat.sub_add_cancel ( show 2 ≤ 2 ^ k n from le_trans ( by decide ) ( pow_le_pow_right₀ ( by decide ) ( show k n ≥ 1 from Nat.succ_le_of_lt ( Nat.pos_of_ne_zero ( by rintro h; simp_all +decide [ Nat.log2 ] ) ) ) ) ) ];
        exact ⟨ b, hb.1, by omega, hb.2.1 ⟩

/-
We define B_finset as the union of two image finsets.
We prove that x is in B_n if and only if x is in B_finset n.
This gives us a decidable instance for membership in B_n.
-/
def B_finset (n : ℕ) : Finset ℕ :=
  (Finset.range (2^(k n - 1))).image (fun j => j * M n) ∪
  (Finset.Ico (2^(k n - 1)) (2^(k n) - 1)).image (fun j => j * M n + 1)

lemma mem_B_iff_mem_B_finset (n x : ℕ) : x ∈ B n ↔ x ∈ B_finset n := by
  -- By definition of $B_finset$, we can split the existence into two cases: $x$ is in the first part or the second part.
  simp [B_finset];
  constructor;
  · rintro ⟨ j, hj ⟩;
    rcases hj with ( ⟨ hj₁, rfl ⟩ | ⟨ hj₁, hj₂, rfl ⟩ );
    · exact Or.inl ⟨ j, lt_of_le_of_lt hj₁ ( Nat.sub_lt ( by positivity ) ( by positivity ) ), rfl ⟩;
    · exact Or.inr ⟨ j, ⟨ hj₁, lt_tsub_iff_right.mpr <| by linarith [ Nat.sub_add_cancel <| show 2 ≤ 2 ^ k n from le_trans ( by decide ) <| Nat.pow_le_pow_right ( by decide ) <| show k n ≥ 1 from Nat.one_le_iff_ne_zero.mpr <| by unfold k; positivity ] ⟩, rfl ⟩;
  · rintro ( ⟨ a, ha, rfl ⟩ | ⟨ a, ⟨ ha₁, ha₂ ⟩, rfl ⟩ );
    · exact ⟨ a, Or.inl ⟨ Nat.le_sub_one_of_lt ha, rfl ⟩ ⟩;
    · exact ⟨ a, Or.inr ⟨ ha₁, by omega, rfl ⟩ ⟩

instance B_decidable (n : ℕ) : DecidablePred (· ∈ B n) := fun x =>
  decidable_of_iff (x ∈ B_finset n) (mem_B_iff_mem_B_finset n x).symm

/-
We define a decidable instance for B_n using the equivalence with B_finset.
-/
instance B_decidable_instance (n : ℕ) : DecidablePred (· ∈ B n) := fun x =>
  decidable_of_iff (x ∈ B_finset n) (mem_B_iff_mem_B_finset n x).symm

/-
We define greedy_choice(n, x) as the largest element of B_n less than or equal to x.
-/
def greedy_choice (n : ℕ) (x : ℕ) : ℕ :=
  Nat.findGreatest (· ∈ B n) x

/-
greedy_choice(n, x) returns an element b in B_n such that b <= x and x - b <= M_n.
-/
lemma greedy_choice_spec (n : ℕ) (x : ℕ) (hx : x ≤ M (n + 1)) :
  let b := greedy_choice n x
  b ∈ B n ∧ b ≤ x ∧ x - b ≤ M n := by
    have := greedy_covering n x hx;
    unfold greedy_choice;
    have := Nat.findGreatest_eq_iff.mp ( rfl : Nat.findGreatest ( fun x => x ∈ B n ) x = _ );
    grind +ring

/-
We define the greedy expansion of m with respect to blocks n_0 to N.
greedy_step(n, r) computes b_n and the new remainder.
greedy_expansion(n_0, N, m) computes the list of coefficients [b_{n_0}, ..., b_N] and the final remainder d.
-/
def greedy_step (n : ℕ) (r : ℕ) : ℕ × ℕ :=
  let b := greedy_choice n r
  (b, r - b)

def greedy_expansion (n_0 N : ℕ) (m : ℕ) : List ℕ × ℕ :=
  let indices := (List.range (N + 1 - n_0)).map (fun i => N - i)
  indices.foldl (fun (acc : List ℕ × ℕ) n =>
    let (bs, r) := acc
    let (b, r') := greedy_step n r
    (b :: bs, r')
  ) ([], m)

/-
The greedy expansion of m satisfies m = sum(bs) + d, d <= M_{n_0}, and each b_i is in B_{n_0+i}.
-/
lemma greedy_expansion_spec (n_0 N m : ℕ) (hm : m ≤ M (N + 1)) :
  let (bs, d) := greedy_expansion n_0 N m
  m = bs.sum + d ∧ d ≤ M n_0 ∧
  bs.length = N + 1 - n_0 ∧
  ∀ i, i < bs.length → bs.get! i ∈ B (n_0 + i) := by
    -- We'll use induction on $N - n_0$ to prove the statement.
    induction' h : N - n_0 with d hd generalizing n_0 N m;
    · unfold greedy_expansion;
      rcases le_total n_0 N with hn | hn <;> simp_all +decide [ Nat.sub_eq_iff_eq_add ];
      · unfold greedy_step;
        have := greedy_choice_spec n_0 m hm; aesop;
      · cases hn.eq_or_lt <;> simp_all +arith +decide [ Nat.sub_eq_zero_of_le ];
        · unfold greedy_step;
          have := greedy_choice_spec n_0 m hm; aesop;
        · simp_all +decide [ Nat.sub_eq_zero_of_le ( by linarith : N + 1 ≤ n_0 ) ];
          exact hm.trans ( M_mono ( by linarith ) );
    · -- Let's denote the greedy expansion of $m$ with respect to blocks $n_0 + 1$ to $N$ as $(bs', d')$.
      obtain ⟨bs', d', hbs', hd'⟩ : ∃ bs' d', greedy_expansion (n_0 + 1) N m = (bs', d') ∧ m = bs'.sum + d' ∧ d' ≤ M (n_0 + 1) ∧ bs'.length = N + 1 - (n_0 + 1) ∧ ∀ i < bs'.length, bs'.get! i ∈ B (n_0 + 1 + i) := by
        grind;
      -- Let's denote the greedy choice of $d'$ with respect to block $n_0$ as $b_0$.
      obtain ⟨b0, hb0⟩ : ∃ b0, greedy_step n_0 d' = (b0, d' - b0) ∧ b0 ∈ B n_0 ∧ b0 ≤ d' ∧ d' - b0 ≤ M n_0 := by
        exact ⟨ _, rfl, greedy_choice_spec n_0 d' hd'.2.1 ⟩;
      rw [ show greedy_expansion n_0 N m = ( b0 :: bs', d' - b0 ) from ?_ ];
      · simp +zetaDelta at *;
        refine' ⟨ _, hb0.2.2.2, _, _ ⟩;
        · linarith [ Nat.sub_add_cancel hb0.2.2.1 ];
        · omega;
        · intro i hi;
          rcases i with ( _ | i ) <;> simp +arith +decide [ hd' ] at hi ⊢;
          · exact hb0.2.1;
          · grind;
      · unfold greedy_expansion at *;
        rw [ show N + 1 - n_0 = ( N + 1 - ( n_0 + 1 ) ) + 1 by omega, List.range_succ ] ; simp +decide [ hbs', hb0 ];
        rw [ Nat.sub_sub_self ( by omega ) ] ; aesop ( simp_config := { singlePass := true } ) ;

/-
c_n is defined as (2^{k_n-1}-1)M_n.
Every element of B_n is a subset sum of the elements in block n.
-/
def c (n : ℕ) : ℕ := (2^(k n - 1) - 1) * M n

lemma mem_subset_sums_block (n x : ℕ) (hx : x ∈ B n) :
  x ∈ subset_sums (fun i => (block n).get! i) := by
    -- By definition of $B_n$, we know that every element in $B_n$ is a subset sum of the elements in $block n$.
    have h_subset_sum : x ∈ Finset.image (fun (idx : Finset ℕ) => ∑ i ∈ idx, (block n).get! i) (Finset.powerset (Finset.range (block n).length)) := by
      rcases hx with ⟨ j, hj | hj ⟩ <;> simp_all +decide [ block ];
      · -- Since $j \leq 2^{k_n-1} - 1$, we can represent $j$ as a sum of distinct powers of 2, each corresponding to an element in the block.
        obtain ⟨I, hI⟩ : ∃ I : Finset ℕ, I ⊆ Finset.range (k n - 1) ∧ j = ∑ i ∈ I, 2^i := by
          have h_binary : ∀ m : ℕ, m < 2^(k n - 1) → ∃ I : Finset ℕ, I ⊆ Finset.range (k n - 1) ∧ m = ∑ i ∈ I, 2^i := by
            intro m hm
            induction' m using Nat.strong_induction_on with m ih;
            rcases Nat.even_or_odd' m with ⟨ c, rfl | rfl ⟩;
            · rcases c with ( _ | c );
              · exact ⟨ ∅, by norm_num ⟩;
              · obtain ⟨ I, hI₁, hI₂ ⟩ := ih ( c + 1 ) ( by linarith ) ( by linarith );
                use I.image (fun i => i + 1);
                simp_all +decide [ Finset.subset_iff, pow_succ', ← Finset.mul_sum _ _ _ ];
                intro x hx; specialize hI₁ hx; contrapose! hm; simp_all +decide [ pow_succ' ] ;
                exact le_trans ( pow_le_pow_right₀ ( by decide ) ( show k n - 1 ≤ x + 1 by omega ) ) ( by rw [ pow_succ' ] ; linarith [ Finset.single_le_sum ( fun i _ => Nat.zero_le ( 2 ^ i ) ) hx ] );
            · obtain ⟨ I, hI₁, hI₂ ⟩ := ih c ( by linarith ) ( by linarith );
              refine' ⟨ I.image ( fun i => i + 1 ) ∪ { 0 }, _, _ ⟩ <;> simp_all +decide [ Finset.subset_iff ];
              · rcases x : k n with ( _ | _ | k ) <;> simp_all +arith +decide [ Nat.pow_succ' ];
                exact fun i hi => lt_of_le_of_ne ( hI₁ hi ) fun con => by have := Finset.single_le_sum ( fun x _ => Nat.zero_le ( 2 ^ x ) ) hi; norm_num [ con ] at this; linarith [ Nat.sub_add_cancel ( show 1 ≤ 2 ^ k from Nat.one_le_pow _ _ ( by decide ) ) ] ;
              · simp +arith +decide [ pow_succ', Finset.mul_sum _ _ _, add_comm ];
          exact h_binary j ( lt_of_le_of_lt hj.1 ( Nat.sub_lt ( by norm_num ) ( by norm_num ) ) );
        refine' ⟨ I, Finset.Subset.trans hI.1 ( Finset.range_mono ( Nat.le_succ _ ) ), _ ⟩;
        rw [ hI.2, Finset.sum_mul _ _ _ ];
        refine' Finset.sum_congr rfl fun i hi => _;
        grind;
      · -- Let's choose the subset $a$ of indices corresponding to the binary representation of $j - 2^{k_n-1} + 1$.
        obtain ⟨a, ha⟩ : ∃ a : Finset ℕ, a ⊆ Finset.range (k n - 1) ∧ ∑ i ∈ a, 2^i = j - 2^(k n - 1) + 1 := by
          have h_binary : ∀ m : ℕ, m < 2^(k n - 1) → ∃ a : Finset ℕ, a ⊆ Finset.range (k n - 1) ∧ ∑ i ∈ a, 2^i = m := by
            intro m hm;
            induction' m using Nat.strong_induction_on with m ih;
            by_cases hm_zero : m = 0;
            · exact ⟨ ∅, Finset.empty_subset _, hm_zero.symm ▸ rfl ⟩;
            · -- Let $i$ be the largest index such that $2^i \leq m$.
              obtain ⟨i, hi⟩ : ∃ i, i < k n - 1 ∧ 2^i ≤ m ∧ m < 2^(i + 1) := by
                exact ⟨ Nat.log 2 m, Nat.log_lt_of_lt_pow ( by positivity ) hm, Nat.pow_le_of_le_log ( by positivity ) ( by linarith ), Nat.lt_pow_of_log_lt ( by linarith ) ( by linarith ) ⟩;
              -- Let $m' = m - 2^i$. Then $m' < m$ and $m' < 2^{k_n-1}$.
              set m' := m - 2^i
              have hm'_lt_m : m' < m := by
                exact Nat.sub_lt ( Nat.pos_of_ne_zero hm_zero ) ( pow_pos ( by decide ) _ )
              have hm'_lt_2k : m' < 2^(k n - 1) := by
                exact lt_of_le_of_lt ( Nat.sub_le _ _ ) hm;
              obtain ⟨ a, ha₁, ha₂ ⟩ := ih m' hm'_lt_m hm'_lt_2k;
              use a ∪ {i};
              rw [ Finset.sum_union ] <;> simp_all +decide [ Finset.subset_iff ];
              · rw [ Nat.sub_add_cancel hi.2.1 ];
              · intro H;
                have := ha₂ ▸ Finset.single_le_sum ( fun x _ => Nat.zero_le ( 2 ^ x ) ) H;
                omega;
          apply h_binary;
          rcases u : k n with ( _ | _ | k ) <;> simp_all +decide [ pow_succ' ] ; omega;
          · linarith;
          · rw [ tsub_add_eq_add_tsub hj.1 ];
            rw [ tsub_lt_iff_left ] <;> linarith [ Nat.sub_add_cancel ( show 2 ≤ 2 * ( 2 * 2 ^ k ) from by linarith [ Nat.one_le_pow k 2 zero_lt_two ] ) ];
        refine' ⟨ a ∪ { k n - 1 }, _, _ ⟩ <;> simp_all +decide [ Finset.subset_iff ];
        · exact fun x hx => Nat.lt_succ_of_lt ( ha.1 hx );
        · rw [ Finset.sum_insert ];
          · simp_all +decide [ List.getElem?_append, List.getElem?_range ];
            rw [ ← Finset.sum_mul _ _ _, ha.2 ];
            nlinarith [ Nat.sub_add_cancel ( show 2 ^ ( k n - 1 ) ≤ j from hj.1 ), Nat.sub_add_cancel ( show 1 ≤ 2 ^ ( k n - 1 ) from Nat.one_le_pow _ _ ( by decide ) ) ];
          · exact fun h => by have := ha.1 h; omega;
    unfold subset_sums; aesop;

/-
c_n + 1 is in the subset sums of block n.
This is because c_n + 1 is exactly the last element of the block.
-/
lemma c_plus_one_mem_block (n : ℕ) : c n + 1 ∈ subset_sums (fun i => (block n).get! i) := by
  use { ( block n |> List.length ) - 1 };
  unfold block c; aesop;

/-
T_seq is the sequence A starting from block n_0.
P_T is the set of subset sums of T_seq.
-/
def T_seq (n_0 : ℕ) (i : ℕ) : ℕ := A_val (block_start n_0 + i)

def P_T (n_0 : ℕ) : Set ℕ := subset_sums (T_seq n_0)

/-
c_count counts the number of indices where b_n = c_n in the greedy expansion.
-/
def c_count (n_0 N m : ℕ) : ℕ :=
  let (bs, d) := greedy_expansion n_0 N m
  (List.range bs.length).filter (fun i => bs.get! i = c (n_0 + i)) |>.length

/-
Combinatorial lemma: If a list has enough elements matching a condition, we can increment d of them to increase the sum by d.
-/
lemma exists_modified_coeffs (bs : List ℕ) (d : ℕ) (c_func : ℕ → ℕ)
  (h_count : ((List.range bs.length).filter (fun i => bs.get! i = c_func i)).length ≥ d) :
  ∃ bs' : List ℕ, bs'.length = bs.length ∧ bs'.sum = bs.sum + d ∧
  ∀ i, i < bs.length →
    (bs'.get! i = bs.get! i ∨ (bs'.get! i = bs.get! i + 1 ∧ bs.get! i = c_func i)) := by
      -- Let's denote the set of indices where bs.get! i = c_func i by S.
      set S := (List.range bs.length).filter (fun i => bs.get! i = c_func i) with hS_def;
      -- Let's choose the first $d$ elements from $S$.
      obtain ⟨T, hT⟩ : ∃ T : Finset ℕ, T.card = d ∧ ∀ i ∈ T, i ∈ S ∧ i < bs.length := by
        obtain ⟨T, hT⟩ : ∃ T : Finset ℕ, T ⊆ S.toFinset ∧ T.card = d := by
          have h_exists_subset : S.toFinset.card ≥ d := by
            rw [ List.toFinset_card_of_nodup ];
            · assumption;
            · exact List.Nodup.filter _ ( List.nodup_range );
          exact?;
        exact ⟨ T, hT.2, fun i hi => ⟨ List.mem_toFinset.mp ( hT.1 hi ), List.mem_range.mp ( List.mem_filter.mp ( List.mem_toFinset.mp ( hT.1 hi ) ) |>.1 ) ⟩ ⟩;
      -- Let's define the new list bs' by adding 1 to each element in T.
      use List.map (fun (i : ℕ) => if i ∈ T then bs.get! i + 1 else bs.get! i) (List.range bs.length);
      have h_sum : (List.map (fun (i : ℕ) => if i ∈ T then bs.get! i + 1 else bs.get! i) (List.range bs.length)).sum = (List.map (fun (i : ℕ) => bs.get! i) (List.range bs.length)).sum + Finset.card T := by
        have h_sum : (List.map (fun (i : ℕ) => if i ∈ T then bs.get! i + 1 else bs.get! i) (List.range bs.length)).sum = (List.map (fun (i : ℕ) => bs.get! i) (List.range bs.length)).sum + (List.map (fun (i : ℕ) => if i ∈ T then 1 else 0) (List.range bs.length)).sum := by
          simpa [ add_comm ] using by rw [ ← List.sum_map_add ] ; congr ; ext i ; aesop;
        convert h_sum using 2;
        have h_card : (List.map (fun (i : ℕ) => if i ∈ T then 1 else 0) (List.range bs.length)).sum = Finset.sum (Finset.range bs.length) (fun i => if i ∈ T then 1 else 0) := by
          exact?;
        rw [ h_card, Finset.sum_boole ];
        rw [ Finset.filter_mem_eq_inter, Finset.inter_eq_right.mpr <| Finset.subset_iff.mpr fun x hx => Finset.mem_range.mpr <| hT.2 x hx |>.2 ] ; aesop;
      simp_all +decide [ List.map_eq_map_iff ];
      refine' ⟨ _, _ ⟩;
      · refine' congr_arg _ ( List.ext_get _ _ ) <;> aesop;
      · grind

/-
T_seq correctly indexes into the blocks.
-/
lemma T_seq_block_eq (n_0 k j : ℕ) (hj : j < (block (n_0 + k)).length) :
  T_seq n_0 (block_start (n_0 + k) - block_start n_0 + j) = (block (n_0 + k)).get! j := by
    -- Let's unfold the definition of `T_seq` using `unfold T_seq`.
    unfold T_seq;
    rw [ ← add_assoc, add_tsub_cancel_of_le ];
    · -- By definition of `A_val`, we know that `A_val (block_start (n_0 + k) + j)` is the `j`-th element of the block at index `n_0 + k`.
      have h_block : block_index (block_start (n_0 + k) + j) = n_0 + k := by
        refine' le_antisymm _ _ <;> contrapose! hj;
        · have := block_index_spec ( block_start ( n_0 + k ) + j );
          -- Since $block_start$ is strictly increasing, we have $block_start (block_index (block_start (n_0 + k) + j)) \geq block_start (n_0 + k + 1)$.
          have h_block_start_ge : block_start (block_index (block_start (n_0 + k) + j)) ≥ block_start (n_0 + k + 1) := by
            exact monotone_nat_of_le_succ ( fun n => by exact Nat.le_add_right _ _ ) hj;
          simp_all +decide [ block_start ];
          linarith;
        · have := block_index_spec ( block_start ( n_0 + k ) + j );
          exact le_of_not_gt fun h => this.2.not_le <| by linarith [ show block_start ( block_index ( block_start ( n_0 + k ) + j ) + 1 ) ≤ block_start ( n_0 + k ) from by exact monotone_nat_of_le_succ ( fun n => by exact Nat.le_add_right _ _ ) hj ] ;
      unfold A_val;
      unfold block_index at h_block; aesop;
    · exact monotone_nat_of_le_succ ( fun n => by exact Nat.le_add_right _ _ ) ( Nat.le_add_right _ _ )

/-
map_index maps (i, j) to the index in T_seq.
-/
def map_index (n_0 i j : ℕ) : ℕ := block_start (n_0 + i) - block_start n_0 + j

/-
map_index maps (i, j) to an index within the range of T_seq corresponding to block (n_0 + i).
-/
lemma map_index_lt (n_0 i j : ℕ) (hj : j < (block (n_0 + i)).length) :
  map_index n_0 i j < block_start (n_0 + i + 1) - block_start n_0 := by
    -- By definition of block_start, we have block_start (n_0 + i + 1) = block_start (n_0 + i) + (block (n_0 + i)).length.
    have h_block_start : block_start (n_0 + i + 1) = block_start (n_0 + i) + (block (n_0 + i)).length := by
      rfl;
    simp +arith +decide [ map_index, h_block_start ];
    exact le_tsub_of_add_le_left ( by linarith [ Nat.sub_add_cancel ( show block_start ( n_0 + i ) ≥ block_start n_0 from by exact monotone_nat_of_le_succ ( fun n => by exact Nat.le_add_right _ _ ) ( by linarith ) ) ] )

/-
map_index maps (i, j) to an index >= the start of the range for block (n_0 + i).
-/
lemma map_index_ge (n_0 i j : ℕ) :
  map_index n_0 i j ≥ block_start (n_0 + i) - block_start n_0 := by
    exact Nat.le_add_right _ _

/-
map_index is injective.
-/
lemma map_index_injective (n_0 : ℕ) :
  ∀ i1 j1 i2 j2,
  j1 < (block (n_0 + i1)).length →
  j2 < (block (n_0 + i2)).length →
  map_index n_0 i1 j1 = map_index n_0 i2 j2 →
  i1 = i2 ∧ j1 = j2 := by
    intro i1 j1 i2 j2 hj1 hj2 h_eq
    by_cases h_cases : i1 < i2 ∨ i2 < i1;
    · cases h_cases <;> [ linarith [ map_index_lt n_0 i1 j1 hj1, map_index_ge n_0 i2 j2, show block_start ( n_0 + i1 + 1 ) - block_start n_0 ≤ block_start ( n_0 + i2 ) - block_start n_0 from Nat.sub_le_sub_right ( block_start_strict_mono.monotone <| by linarith ) _ ] ; linarith [ map_index_lt n_0 i2 j2 hj2, map_index_ge n_0 i1 j1, show block_start ( n_0 + i2 + 1 ) - block_start n_0 ≤ block_start ( n_0 + i1 ) - block_start n_0 from Nat.sub_le_sub_right ( block_start_strict_mono.monotone <| by linarith ) _ ] ];
    · unfold map_index at h_eq; aesop;

/-
If L is a list where the i-th element is a subset sum of the (n_0 + i)-th block, then the sum of L is a subset sum of the sequence starting at block n_0.
-/
lemma sum_of_subset_sums_mem_P_T (n_0 : ℕ) (L : List ℕ)
  (h : ∀ i, i < L.length → L.get! i ∈ subset_sums (fun j => (block (n_0 + i)).get! j)) :
  L.sum ∈ P_T n_0 := by
    -- By definition of $subset_sums$, each element in $L$ is a subset sum of the corresponding block.
    have h_subset_sums : ∀ i < L.length, ∃ s : Finset ℕ, s ⊆ Finset.range (block (n_0 + i)).length ∧ L.get! i = ∑ j ∈ s, (block (n_0 + i)).get! j := by
      intros i hi
      specialize h i hi
      obtain ⟨s, hs⟩ := h;
      use s.filter (fun j => j < (block (n_0 + i)).length);
      simp_all +decide [ Finset.sum_filter ];
      exact ⟨ fun x hx => Finset.mem_range.mpr <| Finset.mem_filter.mp hx |>.2, Finset.sum_congr rfl fun x hx => by aesop ⟩;
    choose! s hs₁ hs₂ using h_subset_sums;
    -- By definition of $P_T$, we need to show that the sum of elements in $L$ is a subset sum of the sequence starting at block $n_0$.
    have h_subset_sum : ∃ S : Finset ℕ, ∑ i ∈ S, T_seq n_0 i = ∑ i ∈ Finset.range L.length, ∑ j ∈ s i, (block (n_0 + i)).get! j := by
      use Finset.biUnion (Finset.range L.length) (fun i => Finset.image (fun j => map_index n_0 i j) (s i));
      rw [ Finset.sum_biUnion ];
      · refine' Finset.sum_congr rfl fun i hi => _;
        rw [ Finset.sum_image ];
        · refine' Finset.sum_congr rfl fun j hj => _;
          exact T_seq_block_eq n_0 i j ( Finset.mem_range.mp ( hs₁ i ( Finset.mem_range.mp hi ) hj ) );
        · intro j hj j' hj' h_eq; have := map_index_injective n_0 i j i j' ( Finset.mem_range.mp ( hs₁ i ( Finset.mem_range.mp hi ) hj ) ) ( Finset.mem_range.mp ( hs₁ i ( Finset.mem_range.mp hi ) hj' ) ) h_eq; aesop;
      · intros i hi j hj hij; simp_all +decide [ Finset.disjoint_left ] ;
        intro a ha x hx; intro H; have := map_index_injective n_0 i a j x; simp_all +decide ;
        exact not_lt_of_ge ( this ( Finset.mem_range.mp ( hs₁ i hi ha ) ) ) ( Finset.mem_range.mp ( hs₁ j hj hx ) );
    obtain ⟨ S, hS ⟩ := h_subset_sum;
    use S;
    rw [ hS, ← Finset.sum_congr rfl fun i hi => hs₂ i ( Finset.mem_range.mp hi ) ];
    simp +decide [ List.sum_eq_foldr, Finset.sum_range ]

/-
The sum of elements in a block subset equals the sum of corresponding elements in T_seq.
-/
lemma sum_block_eq_sum_T_seq (n_0 i : ℕ) (S : Finset ℕ)
  (hS : ∀ j ∈ S, j < (block (n_0 + i)).length) :
  ∑ j ∈ S, (block (n_0 + i)).get! j =
  ∑ k ∈ S.image (map_index n_0 i), T_seq n_0 k := by
    -- By definition of $map\_index$, we know that $T\_seq n\_0 (map\_index n\_0 i j) = (block (n\_0 + i)).get! j$ for any $j \in S$.
    have h_map_index_eq : ∀ j ∈ S, T_seq n_0 (map_index n_0 i j) = (block (n_0 + i)).get! j := by
      intros j hj
      apply T_seq_block_eq n_0 i j (hS j hj);
    rw [ Finset.sum_image, Finset.sum_congr rfl h_map_index_eq ];
    intro j hj j' hj' h_eq; have := map_index_injective n_0 i j i j'; aesop;

/-
Correction Lemma: If the greedy expansion of m has at least M_{n_0} indices where b_n = c_n, then m is in P(T).
-/
lemma correction_lemma (n_0 N m : ℕ) (hm : m ≤ M (N + 1)) :
  c_count n_0 N m ≥ M n_0 → m ∈ P_T n_0 := by
    intro h;
    -- Apply exists_modified_coeffs to get a modified list bs' such that bs'.sum = bs.sum + d and bs'.length = bs.length.
    obtain ⟨bs', hbs'_sum, hbs'_len, hbs'_cond⟩ : ∃ (bs' : List ℕ), bs'.length = (greedy_expansion n_0 N m).fst.length ∧ bs'.sum = (greedy_expansion n_0 N m).fst.sum + (greedy_expansion n_0 N m).snd ∧ ∀ i, i < bs'.length → bs'.get! i = (greedy_expansion n_0 N m).fst.get! i ∨ (bs'.get! i = (greedy_expansion n_0 N m).fst.get! i + 1 ∧ (greedy_expansion n_0 N m).fst.get! i = c (n_0 + i)) := by
      have := exists_modified_coeffs ( greedy_expansion n_0 N m ).1 ( greedy_expansion n_0 N m ).2 ( fun i => c ( n_0 + i ) ) ?_;
      · aesop;
      · exact le_trans ( greedy_expansion_spec n_0 N m hm |>.2.1 ) h;
    -- We need to show that m is in P_T n_0.
    -- It suffices to show that m is a sum of elements, where the i-th element is a subset sum of block (n_0 + i) (by sum_of_subset_sums_mem_P_T).
    have h_subset_sum : ∀ i, i < bs'.length → bs'.get! i ∈ subset_sums (fun j => (block (n_0 + i)).get! j) := by
      intro i hi
      specialize hbs'_cond i hi
      cases' hbs'_cond with h_case1 h_case2;
      · convert mem_subset_sums_block ( n_0 + i ) _ _;
        have := greedy_expansion_spec n_0 N m hm;
        grind;
      · have := c_plus_one_mem_block ( n_0 + i ) ; aesop;
    -- Since m = bs'.sum, we can conclude that m is in P_T n_0.
    have h_final : m = bs'.sum := by
      exact hbs'_len ▸ by simpa using greedy_expansion_spec n_0 N m hm |>.1;
    exact h_final.symm ▸ sum_of_subset_sums_mem_P_T n_0 bs' h_subset_sum

/-
E_N is the number of integers m <= M_{N+1} that are not in P(T).
-/
def E_N (n_0 N : ℕ) : ℕ :=
  ((Finset.range (M (N + 1) + 1)).filter (fun m => m ∉ P_T n_0)).card

/-
The size of the digit set B_n is 2^{k_n} - 1.
-/
def B_card (n : ℕ) : ℕ := (B_finset n).card

lemma B_card_eq (n : ℕ) : B_card n = 2^(k n) - 1 := by
  -- The cardinality of the first set is $2^{k_n - 1}$ and the cardinality of the second set is $2^{k_n} - 2 - 2^{k_n - 1} + 1 = 2^{k_n - 1} - 1$.
  have h_card_first : (Finset.range (2^(k n - 1))).card = 2^(k n - 1) := by
    exact Finset.card_range _
  have h_card_second : (Finset.Ico (2^(k n - 1)) (2^(k n) - 1)).card = 2^(k n - 1) - 1 := by
    rcases k : k n with ( _ | _ | k ) <;> simp_all +decide [ pow_succ' ];
    omega;
  convert congr_arg₂ ( · + · ) h_card_first h_card_second using 1;
  · convert Finset.card_union_of_disjoint _ using 1;
    · rw [ Finset.card_image_of_injective, Finset.card_image_of_injective ] <;> norm_num [ Function.Injective, M_pos ];
      · exact fun a₁ a₂ h => h.resolve_right ( ne_of_gt ( M_pos n ) );
      · exact fun a₁ a₂ h => h.resolve_right ( ne_of_gt ( M_pos n ) );
    · norm_num [ Finset.disjoint_right ];
      intros; subst_vars; nlinarith [ M_pos n ] ;
  · rcases k : k n with ( _ | _ | k ) <;> simp_all +decide [ pow_succ' ];
    · exact absurd k ( by exact ne_of_gt ( Nat.add_pos_left ( by decide ) _ ) );
    · grind

/-
B_prod is the product of the sizes of the digit sets B_n for n from n_0 to N.
-/
def B_prod (n_0 N : ℕ) : ℕ := ∏ n ∈ Finset.Icc n_0 N, B_card n

/-
count_matches counts the number of indices n in [n_0, N] where f(n) = c(n).
-/
def count_matches (n_0 : ℕ) (f : ℕ → ℕ) (N : ℕ) : ℕ :=
  ((Finset.Icc n_0 N).filter (fun n => f n = c n)).card

/-
count_matches_dep counts the number of matches for a dependent function.
bad_functions is the set of dependent functions f such that f(n) in B_n and the number of matches is small.
-/
def count_matches_dep (n_0 N : ℕ) (f : (a : ℕ) → a ∈ Finset.Icc n_0 N → ℕ) : ℕ :=
  ((Finset.Icc n_0 N).attach.filter (fun ⟨n, hn⟩ => f n hn = c n)).card

def bad_functions (n_0 N : ℕ) : Finset ((a : ℕ) → a ∈ Finset.Icc n_0 N → ℕ) :=
  (Finset.pi (Finset.Icc n_0 N) (fun n => B_finset n)).filter (fun f => count_matches_dep n_0 N f < M n_0)

/-
The number of exceptions is bounded by (M n_0 + 1) times the number of bad functions.
-/
lemma E_N_le_bad_functions (n_0 N : ℕ) :
  E_N n_0 N ≤ (M n_0 + 1) * (bad_functions n_0 N).card := by
    by_contra h_contra;
    -- Let's define the set S of exceptions.
    set S := Finset.filter (fun m => m ∉ P_T n_0) (Finset.range (M (N + 1) + 1)) with hS_def;
    -- By definition of $S$, we know that every $m \in S$ has a greedy expansion $(bs, d)$ with $c_count n_0 N m < M n_0$.
    have hS_greedy : ∀ m ∈ S, let (bs, d) := greedy_expansion n_0 N m; count_matches_dep n_0 N (fun i hi => bs.get! (i - n_0)) < M n_0 := by
      intro m hm
      obtain ⟨bs, d, h_greedy⟩ := greedy_expansion_spec n_0 N m (by
      exact Finset.mem_range_succ_iff.mp ( Finset.mem_filter.mp hm |>.1 ));
      -- By definition of $c_count$, we know that $c_count n_0 N m < M n_0$.
      have h_c_count : c_count n_0 N m < M n_0 := by
        apply Classical.byContradiction
        intro h_contra'0; exact (by
        exact Finset.mem_filter.mp hm |>.2 ( correction_lemma n_0 N m ( by linarith [ Finset.mem_range.mp ( Finset.mem_filter.mp hm |>.1 ) ] ) ( by linarith ) ));
      convert h_c_count using 1;
      unfold greedy_expansion c_count count_matches_dep; simp +decide [ Finset.sum_range_succ' ] ;
      rw [ ← Multiset.coe_card ];
      rw [ ← Multiset.toFinset_card_of_nodup ];
      · refine' Finset.card_bij ( fun x hx => x.val - n_0 ) _ _ _ <;> simp +decide [ Finset.mem_filter, Finset.mem_attach ];
        · intro a ha₁ ha₂ ha₃; rw [ Nat.add_sub_cancel' ha₁ ] ;
          exact ⟨ by rw [ show ( greedy_expansion n_0 N m ).1.length = N + 1 - n_0 from h_greedy.1 ] ; omega, ha₃ ⟩;
        · intros; omega;
        · intro b hb hb'; use n_0 + b; simp +decide [ hb', hb ] ;
          exact ⟨ hb', by linarith! [ Nat.sub_add_cancel ( show n_0 ≤ N + 1 from by linarith [ show n_0 ≤ N from by
                                                                                                unfold greedy_expansion at hb; simp +decide [ Finset.sum_range_succ' ] at hb;
                                                                                                grind ] ) ] ⟩;
      · refine' List.Nodup.filter _ _;
        exact?;
    -- Let's define the function that maps each $m \in S$ to its corresponding $(f, d)$ pair.
    set f_map : ℕ → ((a : ℕ) → a ∈ Finset.Icc n_0 N → ℕ) × ℕ := fun m =>
      let (bs, d) := greedy_expansion n_0 N m;
      (fun i hi => bs.get! (i - n_0), d) with hf_map_def;
    -- By definition of $f_map$, we know that $f_map$ is injective on $S$.
    have hf_map_inj : ∀ m1 m2, m1 ∈ S → m2 ∈ S → f_map m1 = f_map m2 → m1 = m2 := by
      intros m1 m2 hm1 hm2 h_eq
      have h_sum_eq : m1 = (greedy_expansion n_0 N m1).1.sum + (greedy_expansion n_0 N m1).2 ∧ m2 = (greedy_expansion n_0 N m2).1.sum + (greedy_expansion n_0 N m2).2 := by
        exact ⟨ greedy_expansion_spec n_0 N m1 ( Finset.mem_range_succ_iff.mp ( Finset.mem_filter.mp hm1 |>.1 ) ) |>.1, greedy_expansion_spec n_0 N m2 ( Finset.mem_range_succ_iff.mp ( Finset.mem_filter.mp hm2 |>.1 ) ) |>.1 ⟩;
      simp +zetaDelta at *;
      rw [ h_sum_eq.1, h_sum_eq.2, h_eq.2 ];
      have h_sum_eq : ∀ i < (greedy_expansion n_0 N m1).1.length, (greedy_expansion n_0 N m1).1.get! i = (greedy_expansion n_0 N m2).1.get! i := by
        intro i hi
        have h_eq_i : (greedy_expansion n_0 N m1).1.get! i = (greedy_expansion n_0 N m2).1.get! i := by
          convert congr_fun ( congr_fun h_eq.1 ( n_0 + i ) ) ( Finset.mem_Icc.mpr ⟨ by linarith, by
            have := greedy_expansion_spec n_0 N m1 ( by linarith );
            grind ⟩ ) using 1 <;> simp +decide [ Nat.add_sub_cancel' ]
        exact h_eq_i;
      have h_sum_eq : (greedy_expansion n_0 N m1).1 = (greedy_expansion n_0 N m2).1 := by
        refine' List.ext_get _ _ <;> norm_num;
        · have := greedy_expansion_spec n_0 N m1 ( by linarith ) ; have := greedy_expansion_spec n_0 N m2 ( by linarith ) ; norm_num at * ; linarith;
        · intro n hn1 hn2; specialize h_sum_eq n hn1; simp +decide [ hn2 ] at h_sum_eq ⊢;
          grind;
      rw [ h_sum_eq ];
    -- By definition of $f_map$, we know that the image of $S$ under $f_map$ is contained in the set of pairs $(f, d)$ where $f$ is a bad function and $d \leq M n_0$.
    have hf_map_image : Finset.image f_map S ⊆ (Finset.pi (Finset.Icc n_0 N) (fun n => B_finset n)).filter (fun f => count_matches_dep n_0 N f < M n_0) ×ˢ Finset.Iic (M n_0) := by
      intro x hx
      obtain ⟨m, hmS, rfl⟩ := Finset.mem_image.mp hx
      have h_f : (fun i hi => (greedy_expansion n_0 N m).1.get! (i - n_0)) ∈ Finset.pi (Finset.Icc n_0 N) (fun n => B_finset n) := by
        have := greedy_expansion_spec n_0 N m ( Finset.mem_range_succ_iff.mp ( Finset.mem_filter.mp hmS |>.1 ) ) ; simp +decide [ Finset.mem_pi ] at this ⊢;
        intro i hi₁ hi₂; specialize this; have := this.2.2.2 ( i - n_0 ) ( by omega ) ; simp +decide [ hi₁, hi₂, Nat.add_sub_of_le hi₁ ] at this ⊢;
        exact?
      have h_d : (greedy_expansion n_0 N m).2 ≤ M n_0 := by
        exact greedy_expansion_spec n_0 N m ( Finset.mem_range_succ_iff.mp ( Finset.mem_filter.mp hmS |>.1 ) ) |>.2.1
      exact Finset.mem_product.mpr ⟨Finset.mem_filter.mpr ⟨h_f, hS_greedy m hmS⟩, Finset.mem_Iic.mpr h_d⟩;
    have := Finset.card_le_card hf_map_image;
    rw [ Finset.card_image_of_injOn fun m1 hm1 m2 hm2 h => hf_map_inj m1 m2 hm1 hm2 h ] at this ; norm_num at *;
    exact h_contra.not_le ( by simpa [ mul_comm ] using this )

/-
The sum of reciprocals of B_card sizes diverges.
-/
def sum_inv_B_card (n_0 N : ℕ) : ℝ := ∑ n ∈ Finset.Icc n_0 N, (1 : ℝ) / B_card n

lemma sum_inv_B_card_diverges (n_0 : ℕ) :
  Filter.Tendsto (fun N => sum_inv_B_card n_0 N) Filter.atTop Filter.atTop := by
    -- By definition of $B_card$, we know that $B_card n \leq 2^{k n} \leq C' \log(n+16)$ for some constants $C$ and $C'$.
    obtain ⟨C, hC⟩ : ∃ C, ∀ n, B_card n ≤ C * Real.log (n + 16) := by
      -- By definition of $B_card$, we know that $B_card n \leq 2^{k n} \leq C' \log(n+16)$ for some constants $C$ and $C'$, using the fact that $k n$ is roughly $\log \log n$.
      have h_B_card_le : ∃ C, ∀ n, B_card n ≤ C * Real.log (n + 16) := by
        have h_k_le : ∃ C, ∀ n, k n ≤ C + Real.logb 2 (Real.logb 2 (n + 16)) := by
          use 4 + 1 + 1;
          intro n
          have h_log2_log2 : clog2 (clog2 (n + 16)) ≤ 1 + Real.logb 2 (Real.logb 2 (n + 16)) := by
            unfold clog2;
            split_ifs <;> norm_num;
            · linarith;
            · grind;
            · exact add_nonneg zero_le_one ( Real.logb_nonneg ( by norm_num ) ( by rw [ Real.le_logb_iff_rpow_le ] <;> norm_num <;> linarith ) );
            · rw [ add_comm ];
              gcongr;
              rw [ Real.le_logb_iff_rpow_le, Real.le_logb_iff_rpow_le ] <;> norm_cast;
              · have h_log2_log2 : 2 ^ (Nat.log2 (Nat.log2 (n + 15))) ≤ Nat.log2 (n + 15) := by
                  rw [ ← Nat.le_log2 ] ; aesop;
                have h_log2_log2 : 2 ^ (Nat.log2 (n + 15)) ≤ n + 15 := by
                  rw [ ← Nat.le_log2 ] ; norm_num;
                exact le_trans ( pow_le_pow_right₀ ( by decide ) ‹_› ) ( by linarith );
              · linarith;
              · exact Real.logb_pos ( by norm_num ) ( by norm_cast; linarith );
          unfold k; norm_num; linarith;
        -- Using the bound on $k_n$, we can show that $2^{k_n} \leq C' \log(n+16)$ for some constant $C'$.
        obtain ⟨C', hC'⟩ : ∃ C', ∀ n, (2 : ℝ)^(k n) ≤ C' * Real.log (n + 16) := by
          obtain ⟨ C, hC ⟩ := h_k_le;
          -- Using the bound on $k_n$, we can show that $2^{k_n} \leq 2^C \cdot \log_2(n+16)$.
          have h_exp_bound : ∀ n, (2 : ℝ)^(k n) ≤ 2^C * Real.logb 2 (n + 16) := by
            intro n
            have : (2 : ℝ)^(k n) ≤ (2 : ℝ)^(C + Real.logb 2 (Real.logb 2 (n + 16))) := by
              exact_mod_cast Real.rpow_le_rpow_of_exponent_le one_le_two ( hC n );
            convert this using 1 ; rw [ Real.rpow_add ( by positivity ), Real.rpow_logb ( by positivity ) ( by norm_num ) ( Real.logb_pos ( by norm_num ) ( by linarith ) ) ];
          exact ⟨ 2 ^ C / Real.log 2, fun n => le_trans ( h_exp_bound n ) ( by rw [ Real.logb ] ; ring_nf; norm_num ) ⟩;
        use C';
        intro n; specialize hC' n; rw [ show B_card n = 2 ^ ( k n ) - 1 from _ ] ;
        · simpa using hC'.trans' ( sub_le_self _ zero_le_one );
        · convert B_card_eq n;
      exact h_B_card_le;
    -- Since $1 / B_card n \geq c / \log(n+16)$, and the sum of $1 / \log(n+16)$ diverges, it follows that the sum of $1 / B_card n$ also diverges.
    have h_diverge : Filter.Tendsto (fun N => ∑ n ∈ Finset.Icc n_0 N, (1 : ℝ) / (C * Real.log (n + 16))) Filter.atTop Filter.atTop := by
      -- The sum of $1 / \log(n+16)$ diverges because it behaves like the harmonic series.
      have h_harmonic : Filter.Tendsto (fun N => ∑ n ∈ Finset.Icc n_0 N, (1 : ℝ) / Real.log (n + 16)) Filter.atTop Filter.atTop := by
        -- We can compare our sum to the harmonic series, which is known to diverge.
        have h_harmonic : Filter.Tendsto (fun N => ∑ n ∈ Finset.range (N + 1 - n_0), (1 : ℝ) / Real.log (n + n_0 + 16)) Filter.atTop Filter.atTop := by
          -- We can compare our sum to the harmonic series, which is known to diverge. We use the fact that $\frac{1}{\log(n + n_0 + 16)} \geq \frac{1}{n + n_0 + 16}$.
          have h_harmonic : Filter.Tendsto (fun N => ∑ n ∈ Finset.range (N + 1 - n_0), (1 : ℝ) / (n + n_0 + 16)) Filter.atTop Filter.atTop := by
            exact not_summable_iff_tendsto_nat_atTop_of_nonneg ( fun _ => by positivity ) |>.1 ( by exact_mod_cast mt ( summable_nat_add_iff ( n_0 + 16 ) |>.1 ) Real.not_summable_one_div_natCast ) |> Filter.Tendsto.comp <| Filter.tendsto_sub_atTop_nat n_0 |> Filter.Tendsto.comp <| Filter.tendsto_add_atTop_nat 1;
          refine' Filter.tendsto_atTop_mono ( fun N => Finset.sum_le_sum fun _ _ => one_div_le_one_div_of_le ( Real.log_pos <| by linarith ) <| le_trans ( Real.log_le_sub_one_of_pos <| by linarith ) <| by linarith ) h_harmonic;
        refine h_harmonic.congr' ?_;
        filter_upwards [ Filter.eventually_ge_atTop n_0 ] with N hN;
        erw [ Finset.sum_Ico_eq_sum_range ] ; norm_num [ add_comm, add_left_comm, add_assoc ];
      convert h_harmonic.const_mul_atTop ( show 0 < ( C : ℝ ) ⁻¹ from inv_pos.mpr <| ?_ ) using 2 ; norm_num [ div_eq_mul_inv, Finset.mul_sum _ _ _ ];
      · grind;
      · have := hC 0; norm_num at this;
        exact lt_of_not_ge fun h => by nlinarith [ show ( B_card 0 : ℝ ) > 0 from mod_cast by native_decide, Real.log_pos ( show 16 > 1 by norm_num ) ] ;
    refine' Filter.tendsto_atTop_mono' _ _ h_diverge;
    filter_upwards [ Filter.eventually_ge_atTop n_0 ] with N hN;
    exact Finset.sum_le_sum fun i hi => one_div_le_one_div_of_le ( Nat.cast_pos.mpr <| Finset.card_pos.mpr ⟨ 0, by unfold B_finset; aesop ⟩ ) <| hC i

#check Multiset.esymm

def a_seq (n : ℕ) : ℝ := (B_card n : ℝ) - 1

def symmetric_bound (n_0 N : ℕ) : ℝ :=
  (∏ n ∈ Finset.Icc n_0 N, a_seq n) *
  ∑ j ∈ Finset.range (M n_0), ((Finset.Icc n_0 N).val.map (fun n => 1 / a_seq n)).esymm j

def exact_matches (n_0 N : ℕ) (J : Finset ℕ) : Finset ((a : ℕ) → a ∈ Finset.Icc n_0 N → ℕ) :=
  (Finset.pi (Finset.Icc n_0 N) (fun n => B_finset n)).filter (fun f =>
    ∀ n (hn : n ∈ Finset.Icc n_0 N), f n hn = c n ↔ n ∈ J)

/-
c n is in B_finset n.
-/
lemma c_mem_B_finset (n : ℕ) : c n ∈ B_finset n := by
  unfold B_finset; aesop;

/-
choices J n is {c n} if n in J, else B_finset n \ {c n}.
The cardinality of choices J n is 1 if n in J, else B_card n - 1.
-/
def choices (J : Finset ℕ) (n : ℕ) : Finset ℕ :=
  if n ∈ J then {c n} else (B_finset n).erase (c n)

lemma choices_card (n : ℕ) (J : Finset ℕ) :
  (choices J n).card = if n ∈ J then 1 else B_card n - 1 := by
    unfold choices B_card;
    split_ifs <;> simp +decide [ *, Finset.card_erase_of_mem ( show c n ∈ B_finset n from by exact Finset.mem_union_left _ <| Finset.mem_image_of_mem _ <| Finset.mem_range.mpr <| Nat.sub_lt ( by norm_num ) zero_lt_one ) ]

/-
exact_matches is the product of choices.
-/
lemma exact_matches_eq_pi (n_0 N : ℕ) (J : Finset ℕ) :
  exact_matches n_0 N J = Finset.pi (Finset.Icc n_0 N) (fun n => choices J n) := by
    ext f
    simp [choices, exact_matches];
    constructor;
    · grind;
    · intro hf
      constructor;
      · intro a hp hq; specialize hf a hp hq; split_ifs at hf <;> simp_all +decide [ B_finset ] ;
        exact Or.inl ⟨ 2 ^ ( k a - 1 ) - 1, by exact Nat.sub_lt ( by positivity ) ( by positivity ), by simp +decide [ c ] ⟩;
      · intro n hn hn'; specialize hf n hn hn'; aesop;

/-
The number of functions with exactly a set J of matches is the product of (B_card n - 1) for n not in J.
-/
lemma exact_matches_card (n_0 N : ℕ) (J : Finset ℕ) (hJ : J ⊆ Finset.Icc n_0 N) :
  (exact_matches n_0 N J).card = ∏ n ∈ (Finset.Icc n_0 N) \ J, (B_card n - 1) := by
    -- Apply the lemma that states the cardinality of the product of choices is the product of the cardinalities of the choices.
    have h_card_pi : (exact_matches n_0 N J).card = Finset.prod (Finset.Icc n_0 N) (fun n => (choices J n).card) := by
      convert Finset.card_pi _ _;
      convert congr_arg Finset.card ( exact_matches_eq_pi n_0 N J );
    rw [ h_card_pi, Finset.prod_congr rfl fun x hx => choices_card x J ];
    simp +decide [ Finset.prod_ite, Finset.sdiff_eq_filter ]

def bad_index_sets (n_0 N : ℕ) : Finset (Finset ℕ) :=
  (Finset.powerset (Finset.Icc n_0 N)).filter (fun J => J.card < M n_0)

def matches_of (n_0 N : ℕ) (f : (a : ℕ) → a ∈ Finset.Icc n_0 N → ℕ) : Finset ℕ :=
  (Finset.Icc n_0 N).attach.filter (fun ⟨n, hn⟩ => f n hn = c n) |>.map ⟨Subtype.val, Subtype.val_injective⟩

/-
For a valid function f and subset J, f is in exact_matches J iff its matches are exactly J.
-/
lemma mem_exact_matches_iff (n_0 N : ℕ) (J : Finset ℕ) (hJ : J ⊆ Finset.Icc n_0 N)
  (f : (a : ℕ) → a ∈ Finset.Icc n_0 N → ℕ) (hf : f ∈ Finset.pi (Finset.Icc n_0 N) (fun n => B_finset n)) :
  f ∈ exact_matches n_0 N J ↔ matches_of n_0 N f = J := by
    unfold exact_matches matches_of;
    constructor <;> intro h <;> simp_all +decide [ Finset.ext_iff ];
    · exact fun x hx => Finset.mem_Icc.mp ( hJ hx );
    · exact fun n hp hq => by specialize h n; aesop;

/-
exact_matches J1 and exact_matches J2 are disjoint if J1 != J2.
-/
lemma exact_matches_disjoint (n_0 N : ℕ) (J1 J2 : Finset ℕ) (hJ1 : J1 ⊆ Finset.Icc n_0 N) (hJ2 : J2 ⊆ Finset.Icc n_0 N) (h : J1 ≠ J2) :
  Disjoint (exact_matches n_0 N J1) (exact_matches n_0 N J2) := by
    exact Finset.disjoint_left.mpr fun x hx1 hx2 => h <| by have := mem_exact_matches_iff n_0 N J1 hJ1 x ( Finset.mem_filter.mp hx1 |>.1 ) ; have := mem_exact_matches_iff n_0 N J2 hJ2 x ( Finset.mem_filter.mp hx2 |>.1 ) ; aesop;

/-
bad_functions is the union of exact_matches J for all J in bad_index_sets.
-/
lemma bad_functions_eq_union (n_0 N : ℕ) :
  bad_functions n_0 N = (bad_index_sets n_0 N).biUnion (fun J => exact_matches n_0 N J) := by
    ext
    simp [bad_functions, bad_index_sets, exact_matches];
    constructor;
    · intro h
      use (Finset.Icc n_0 N).attach.filter (fun ⟨n, hn⟩ => (‹(a : ℕ) → a ∈ Finset.Icc n_0 N → ℕ› n hn) = c n) |>.map ⟨Subtype.val, Subtype.val_injective⟩;
      simp_all +decide [ Finset.subset_iff ];
      convert h.2 using 1;
    · unfold count_matches_dep;
      rintro ⟨ J, hJ₁, hJ₂, hJ₃ ⟩;
      refine' ⟨ hJ₂, lt_of_le_of_lt _ hJ₁.2 ⟩;
      rw [ ← Finset.card_image_of_injective _ Subtype.coe_injective ] ; exact Finset.card_mono <| fun x hx => by aesop;

/-
a_seq n is positive.
-/
lemma a_seq_pos (n : ℕ) : 0 < a_seq n := by
  exact sub_pos_of_lt ( mod_cast B_card_eq n ▸ Nat.le_sub_one_of_lt ( by exact lt_of_lt_of_le ( by decide ) ( Nat.pow_le_pow_right ( by decide ) ( show k n ≥ 4 by exact le_add_of_nonneg_right ( Nat.zero_le _ ) ) ) ) )

/-
(Product of f) * esymm_k(1/f) = Sum over subsets t of size k of (Product of f over s \ t).
-/
lemma esymm_recip_eq_sum_subsets {α : Type*} [DecidableEq α] (s : Finset α) (k : ℕ) (f : α → ℝ) (hf : ∀ x ∈ s, f x ≠ 0) :
  (∏ x ∈ s, f x) * (s.val.map (fun x => 1 / f x)).esymm k = ∑ t ∈ s.powersetCard k, ∏ x ∈ s \ t, f x := by
    -- By definition of esymm, we can rewrite the left-hand side as a sum over subsets of size k.
    have h_esymm : (Multiset.map (fun x => 1 / f x) s.val).esymm k = ∑ t ∈ Finset.powersetCard k s, (∏ x ∈ t, (1 / f x)) := by
      exact?;
    rw [ h_esymm, Finset.mul_sum _ _ _ ];
    refine' Finset.sum_congr rfl fun t ht => _;
    rw [ ← Finset.prod_sdiff ( Finset.mem_powersetCard.mp ht |>.1 ) ];
    simp +decide [ Finset.prod_eq_zero_iff, hf ];
    rw [ mul_assoc, mul_inv_cancel₀ ( Finset.prod_ne_zero_iff.mpr fun x hx => hf x ( Finset.mem_powersetCard.mp ht |>.1 hx ) ), mul_one ]

/-
The number of bad greedy expansions is bounded by elementary symmetric sums.
-/
theorem bad_functions_bound (n_0 N : ℕ) :
  (bad_functions n_0 N).card ≤ symmetric_bound n_0 N := by
    -- By definition of $bad_functions$, we know that
    have h_bad_functions : (bad_functions n_0 N).card = ∑ J ∈ bad_index_sets n_0 N, (exact_matches n_0 N J).card := by
      rw [ bad_functions_eq_union, Finset.card_biUnion ];
      exact fun J hJ J' hJ' h => exact_matches_disjoint n_0 N J J' ( Finset.mem_powerset.mp ( Finset.mem_filter.mp hJ |>.1 ) ) ( Finset.mem_powerset.mp ( Finset.mem_filter.mp hJ' |>.1 ) ) h;
    -- Substitute the expression for the cardinality of exact_matches into the sum.
    have h_subst : (bad_functions n_0 N).card = ∑ j ∈ Finset.range (M n_0), ∑ J ∈ Finset.powersetCard j (Finset.Icc n_0 N), ∏ n ∈ (Finset.Icc n_0 N) \ J, a_seq n := by
      have h_subst : (bad_functions n_0 N).card = ∑ J ∈ (Finset.powerset (Finset.Icc n_0 N)).filter (fun J => J.card < M n_0), ∏ n ∈ (Finset.Icc n_0 N) \ J, a_seq n := by
        convert congr_arg ( ( ↑ ) : ℕ → ℝ ) h_bad_functions using 1;
        push_cast [ bad_index_sets ];
        refine' Finset.sum_congr rfl fun J hJ => _;
        convert exact_matches_card n_0 N J _ |> Eq.symm using 1;
        · unfold a_seq; norm_num [ ← @Nat.cast_inj ℝ ] ;
          rw [ Finset.prod_congr rfl fun x hx => Nat.cast_pred <| Nat.one_le_iff_ne_zero.mpr <| by
            exact ne_of_gt ( B_card_eq x ▸ Nat.sub_pos_of_lt ( one_lt_pow₀ ( by norm_num ) ( by unfold k; aesop ) ) ) ];
        · exact Finset.mem_powerset.mp ( Finset.mem_filter.mp hJ |>.1 );
      rw [ h_subst, Finset.sum_sigma' ];
      refine' Finset.sum_bij ( fun J hJ => ⟨ J.card, J ⟩ ) _ _ _ _ <;> aesop;
    -- By definition of $symmetric_bound$, we know that
    have h_symmetric_bound : symmetric_bound n_0 N = ∑ j ∈ Finset.range (M n_0), (∏ n ∈ Finset.Icc n_0 N, a_seq n) * ((Finset.Icc n_0 N).val.map (fun n => 1 / a_seq n)).esymm j := by
      exact Finset.mul_sum _ _ _;
    -- By definition of $esymm$, we know that
    have h_esymm : ∀ j ∈ Finset.range (M n_0), (∏ n ∈ Finset.Icc n_0 N, a_seq n) * ((Finset.Icc n_0 N).val.map (fun n => 1 / a_seq n)).esymm j = ∑ J ∈ Finset.powersetCard j (Finset.Icc n_0 N), ∏ n ∈ (Finset.Icc n_0 N) \ J, a_seq n := by
      intros j hj;
      convert esymm_recip_eq_sum_subsets ( Finset.Icc n_0 N ) j ( fun n => a_seq n ) ( fun n hn => ne_of_gt ( a_seq_pos n ) ) using 1;
    rw [ h_subst, h_symmetric_bound, Finset.sum_congr rfl h_esymm ]

/-
M_{n+1} is at least M_n * product_term n - 1.
-/
def product_term (n : ℕ) : ℝ := a_seq n + 1/2

lemma M_recurrence_ineq (n : ℕ) : (M (n + 1) : ℝ) ≥ M n * product_term n - 1 := by
  -- By definition of $M$, we know that $M (n + 1) = \left\lfloor \left(2^{k n + 1} - 3\right) \frac{M n}{2} \right\rfloor$.
  have hM_def : M (n + 1) = (M n * (2^(k n + 1) - 3)) / 2 := by
    rfl;
  unfold product_term; norm_num [ hM_def ] ; ring_nf; norm_num;
  unfold a_seq ; ring_nf; norm_num;
  rw [ show B_card n = 2 ^ k n - 1 from ?_ ] ; norm_num [ Nat.cast_sub ( show 3 ≤ 2 ^ k n * 2 from by linarith [ Nat.pow_le_pow_right two_pos ( show k n ≥ 1 from by exact Nat.succ_le_of_lt ( by exact add_pos_of_pos_of_nonneg zero_lt_four ( Nat.zero_le _ ) ) ) ] ) ] ; ring_nf ; norm_num;
  · field_simp;
    norm_cast ; nlinarith [ Nat.div_add_mod ( M n * ( 2 ^ k n * 2 - 3 ) ) 2, Nat.mod_lt ( M n * ( 2 ^ k n * 2 - 3 ) ) two_pos, Nat.sub_add_cancel ( show 3 ≤ 2 ^ k n * 2 from by linarith [ Nat.pow_le_pow_right two_pos ( show k n ≥ 1 from by exact Nat.succ_le_of_lt ( by exact add_pos_of_pos_of_nonneg zero_lt_four ( Nat.zero_le _ ) ) ) ] ) ];
  · exact?

/-
The ratio M_n / P_n decreases by at most 1 / P_{n+1} at each step.
-/
def partial_prod (n_0 n : ℕ) : ℝ := ∏ k ∈ Finset.Ico n_0 n, product_term k

lemma ratio_recurrence (n_0 n : ℕ) (hn : n ≥ n_0) :
  (M (n + 1) : ℝ) / partial_prod n_0 (n + 1) ≥ (M n : ℝ) / partial_prod n_0 n - 1 / partial_prod n_0 (n + 1) := by
    -- By definition of partial_prod, we have partial_prod n_0 (n + 1) = partial_prod n_0 n * product_term n.
    have h_partial_prod_succ : partial_prod n_0 (n + 1) = partial_prod n_0 n * product_term n := by
      unfold partial_prod;
      rw [ Finset.prod_Ico_succ_top ( by linarith ) ];
    -- By multiplying both sides of the inequality by partial_prod n_0 (n + 1), we can eliminate the denominators.
    have h_mul : (M (n + 1) : ℝ) ≥ (M n : ℝ) * product_term n - 1 := by
      exact?;
    rw [ h_partial_prod_succ, ge_iff_le, sub_div' ];
    · field_simp;
      gcongr;
      · apply_rules [ mul_nonneg, Finset.prod_nonneg ] <;> norm_num [ product_term ];
        · exact fun i hi₁ hi₂ => add_nonneg ( le_of_lt ( a_seq_pos i ) ) ( by norm_num );
        · exact add_nonneg ( le_of_lt ( a_seq_pos n ) ) ( by norm_num );
      · rw [ mul_right_comm, mul_div_cancel_right₀ _ ( ne_of_gt <| ?_ ) ] ; linarith;
        refine' Finset.prod_pos fun i hi => _;
        exact add_pos_of_nonneg_of_pos ( sub_nonneg_of_le ( mod_cast Nat.one_le_iff_ne_zero.mpr <| by { unfold B_card; unfold B_finset; aesop } ) ) ( by norm_num );
    · refine' mul_ne_zero _ _;
      · refine' Finset.prod_ne_zero_iff.mpr _;
        exact fun x hx => ne_of_gt <| add_pos_of_nonneg_of_pos ( le_of_lt <| a_seq_pos x ) <| by norm_num;
      · exact ne_of_gt ( add_pos_of_nonneg_of_pos ( le_of_lt ( a_seq_pos n ) ) ( by norm_num ) )

/-
M_{N+1} is at least a constant times the product of (a_n + 1/2).
-/
theorem M_lower_bound (n_0 : ℕ) :
  ∃ c > 0, ∀ N ≥ n_0, (M (N + 1) : ℝ) ≥ c * M n_0 * ∏ n ∈ Finset.Icc n_0 N, product_term n := by
    -- Let $c = \frac{M_{n_0} - \sum_{k=n_0}^\infty 1/P_k}{M_{n_0}}$.
    obtain ⟨c, hc_pos, hc⟩ : ∃ c > 0, ∀ N ≥ n_0, (M (N + 1) : ℝ) / (∏ n ∈ Finset.Icc n_0 N, product_term n) ≥ c * (M n_0 : ℝ) := by
      -- Let $c = \frac{M_{n_0} - \sum_{k=n_0}^\infty 1/P_k}{M_{n_0}}$ and show that it is positive.
      obtain ⟨c, hc_pos, hc⟩ : ∃ c > 0, (M n_0 : ℝ) - ∑' k : ℕ, 1 / (∏ n ∈ Finset.Ico n_0 (n_0 + k), product_term n) / product_term (n_0 + k) ≥ c * (M n_0 : ℝ) := by
        -- The series $\sum_{k=n_0}^\infty 1/P_k$ is bounded by a geometric series with ratio roughly $1/14$.
        have h_geo_series : ∑' k : ℕ, (1 / (∏ n ∈ Finset.Ico n_0 (n_0 + k), product_term n) / product_term (n_0 + k)) ≤ 1 / (14 * (1 - 1 / 14)) := by
          -- We'll use the fact that $product\_term(n) \geq 14$ for all $n \geq n_0$.
          have h_prod_term_ge_14 : ∀ n ≥ n_0, product_term n ≥ 14 := by
            intro n hn
            have h_k_ge_4 : 4 ≤ k n := by
              exact le_add_of_nonneg_right ( Nat.zero_le _ );
            -- Since $B_card n \geq 15$, we have $product\_term n = (B_card n : ℝ) - 1 + 1/2 \geq 15 - 1 + 1/2 = 14.5$.
            have h_B_card_ge_15 : 15 ≤ B_card n := by
              rw [ show B_card n = 2 ^ ( k n ) - 1 from B_card_eq n ] ; exact Nat.le_sub_one_of_lt ( lt_of_lt_of_le ( by decide ) ( Nat.pow_le_pow_right ( by decide ) h_k_ge_4 ) ) ;
            exact le_trans ( by norm_num ) ( add_le_add ( show ( B_card n : ℝ ) - 1 ≥ 14 by exact le_tsub_of_add_le_left ( mod_cast h_B_card_ge_15 ) ) le_rfl );
          -- Using the bound $product\_term(n) \geq 14$, we can show that the series is bounded above by a geometric series.
          have h_geo_series_bound : ∀ k : ℕ, (1 / (∏ n ∈ Finset.Ico n_0 (n_0 + k), product_term n) / product_term (n_0 + k)) ≤ (1 / 14) ^ (k + 1) := by
            intro k
            have h_prod_ge_14 : (∏ n ∈ Finset.Ico n_0 (n_0 + k), product_term n) ≥ 14^k := by
              exact le_trans ( by norm_num ) ( Finset.prod_le_prod ( fun _ _ => by norm_num ) fun _ _ => h_prod_term_ge_14 _ <| Finset.mem_Ico.mp ‹_› |>.1 )
            have h_term_le : (1 / (∏ n ∈ Finset.Ico n_0 (n_0 + k), product_term n) / product_term (n_0 + k)) ≤ (1 / 14^k) / 14 := by
              gcongr ; aesop
            simp_all +decide [ div_eq_mul_inv, pow_succ' ];
            exact h_term_le.trans_eq ( mul_comm _ _ );
          refine' le_trans ( Summable.tsum_le_tsum h_geo_series_bound _ _ ) _;
          · exact Summable.of_nonneg_of_le ( fun k => div_nonneg ( one_div_nonneg.mpr ( Finset.prod_nonneg fun _ _ => le_trans ( by norm_num ) ( h_prod_term_ge_14 _ ( by linarith [ Finset.mem_Ico.mp ‹_› ] ) ) ) ) ( le_trans ( by norm_num ) ( h_prod_term_ge_14 _ ( by linarith ) ) ) ) h_geo_series_bound ( by simpa using summable_nat_add_iff 1 |>.2 <| summable_geometric_of_lt_one ( by norm_num ) <| show ( 1 : ℝ ) / 14 < 1 by norm_num );
          · exact Summable.comp_injective ( summable_geometric_of_lt_one ( by norm_num ) ( by norm_num ) ) ( Nat.succ_injective );
          · ring_nf; rw [ tsum_mul_right, tsum_geometric_of_lt_one ] <;> norm_num;
        -- Since $M_{n_0} \ge 10$, we can take $c = \frac{M_{n_0} - \sum_{k=n_0}^\infty 1/P_k}{M_{n_0}}$.
        use (M n_0 - 1 / (14 * (1 - 1 / 14))) / M n_0;
        field_simp;
        rw [ lt_div_iff₀, div_le_iff₀ ] <;> norm_num at *;
        · constructor <;> norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm ] at *;
          · exact_mod_cast by linarith [ M_pos n_0 ] ;
          · exact mul_le_mul_of_nonneg_left ( by linarith ) ( Nat.cast_nonneg _ );
        · exact?;
        · exact?;
      -- By the ratio recurrence inequality, we have that $M_{N+1}/P_N \ge M_{n_0} - \sum_{k=n_0}^N 1/P_k$.
      have h_ratio_recurrence : ∀ N ≥ n_0, (M (N + 1) : ℝ) / (∏ n ∈ Finset.Icc n_0 N, product_term n) ≥ (M n_0 : ℝ) - ∑ k ∈ Finset.range (N - n_0 + 1), 1 / (∏ n ∈ Finset.Ico n_0 (n_0 + k), product_term n) / product_term (n_0 + k) := by
        intro N hN;
        induction' hN with N hN ih;
        · field_simp;
          convert ratio_recurrence n_0 n_0 le_rfl |> le_trans _ using 1;
          unfold partial_prod; norm_num [ Finset.prod_range_succ ] ;
        · have h_ratio_recurrence_step : (M (N + 2) : ℝ) / (∏ n ∈ Finset.Icc n_0 (N + 1), product_term n) ≥ (M (N + 1) : ℝ) / (∏ n ∈ Finset.Icc n_0 N, product_term n) - 1 / (∏ n ∈ Finset.Ico n_0 (N + 1), product_term n) / product_term (N + 1) := by
            have := ratio_recurrence n_0 ( N + 1 ) ( by linarith [ Nat.succ_le_succ hN ] ) ; simp_all +decide [ Nat.Ico_succ_right, Finset.prod_Ioc_succ_top, Nat.Icc_succ_left ] ;
            convert this using 1;
            unfold partial_prod; erw [ Finset.prod_Ico_succ_top ( by linarith ), Finset.prod_Ico_succ_top ( by linarith ) ] ; ring;
          simp_all +decide [ Nat.succ_sub ( show n_0 ≤ N from hN ), Finset.sum_range_succ ];
          rw [ show n_0 + ( N - n_0 + 1 ) = N + 1 by linarith [ Nat.sub_add_cancel hN ] ] ; ring_nf at * ; linarith;
      refine' ⟨ c, hc_pos, fun N hN => le_trans _ ( h_ratio_recurrence N hN ) ⟩;
      refine' le_trans hc ( sub_le_sub_left _ _ );
      field_simp;
      refine' Summable.sum_le_tsum _ _ _;
      · intro i hi; exact div_nonneg zero_le_one ( mul_nonneg ( Finset.prod_nonneg fun _ _ => le_of_lt ( show 0 < product_term _ from add_pos_of_nonneg_of_pos ( le_of_lt ( a_seq_pos _ ) ) ( by norm_num ) ) ) ( le_of_lt ( show 0 < product_term _ from add_pos_of_nonneg_of_pos ( le_of_lt ( a_seq_pos _ ) ) ( by norm_num ) ) ) ) ;
      · -- We'll use the fact that the product of terms greater than 1 grows exponentially.
        have h_prod_growth : ∀ n ≥ n_0, product_term n ≥ 2.5 := by
          intro n hn; unfold product_term; norm_num;
          unfold a_seq;
          rw [ show B_card n = 2 ^ ( k n ) - 1 from B_card_eq n ] ; rw [ Nat.cast_sub <| Nat.one_le_pow _ _ <| by decide ] ; norm_num ; ring_nf ; norm_num;
          exact le_trans ( by norm_num ) ( pow_le_pow_right₀ ( by norm_num ) ( show k n ≥ 2 by exact le_add_of_le_of_nonneg ( by norm_num ) ( Nat.zero_le _ ) ) );
        -- Using the growth rate of the product, we can bound the terms of the series.
        have h_term_bound : ∀ x : ℕ, (1 : ℝ) / ((∏ n ∈ Finset.Ico n_0 (n_0 + x), product_term n) * product_term (n_0 + x)) ≤ (1 : ℝ) / (2.5 ^ (x + 1)) := by
          intro x; gcongr;
          induction' x with x ih <;> norm_num [ Finset.prod_Ico_succ_top, pow_succ' ] at *;
          · exact h_prod_growth _ le_rfl;
          · rw [ Nat.add_succ, Finset.prod_Ico_succ_top ( by linarith ) ];
            nlinarith [ h_prod_growth ( n_0 + x + 1 ) ( by linarith ), pow_pos ( by norm_num : ( 0 : ℝ ) < 5 / 2 ) x ];
        exact Summable.of_nonneg_of_le ( fun x => div_nonneg zero_le_one ( mul_nonneg ( Finset.prod_nonneg fun _ _ => le_trans ( by norm_num ) ( h_prod_growth _ ( by linarith [ Finset.mem_Ico.mp ‹_› ] ) ) ) ( le_trans ( by norm_num ) ( h_prod_growth _ ( by linarith ) ) ) ) ) h_term_bound ( by simpa using summable_nat_add_iff 1 |>.2 <| summable_geometric_of_lt_one ( by norm_num ) <| inv_lt_one_of_one_lt₀ <| by norm_num );
    exact ⟨ c, hc_pos, fun N hN => by have := hc N hN; rwa [ ge_iff_le, le_div_iff₀ ( Finset.prod_pos fun n hn => by exact add_pos_of_pos_of_nonneg ( a_seq_pos n ) ( by norm_num ) ) ] at this ⟩

/-
The ratio M_{N+1}/P_N is at least M_{n_0} minus the sum of reciprocals of P_k.
-/
lemma M_ratio_lower_bound (n_0 N : ℕ) (hN : N ≥ n_0) :
  (M (N + 1) : ℝ) / partial_prod n_0 (N + 1) ≥ (M n_0 : ℝ) - ∑ k ∈ Finset.Icc n_0 N, 1 / partial_prod n_0 (k + 1) := by
    have := @ratio_recurrence n_0 N;
    induction' hN with N hN ih;
    · convert this le_rfl using 1 ; norm_num [ partial_prod ];
    · erw [ Finset.sum_Ico_succ_top ( by linarith [ Nat.succ_le_succ hN ] ) ];
      have := ih ( fun _ => ?_ ) ; simp_all +decide [ Finset.sum_Ico_succ_top ] ;
      · rw [ Finset.Icc_eq_cons_Ico ( by linarith ), Finset.sum_cons ] at this ; linarith [ ‹n_0 ≤ N + 1 → _› ( by linarith ) ];
      · exact?

/-
M_{N+1} is at least a constant times the product of (a_n + 1/2).
-/
theorem M_lower_bound_proven (n_0 : ℕ) :
  ∃ c > 0, ∀ N ≥ n_0, (M (N + 1) : ℝ) ≥ c * M n_0 * ∏ n ∈ Finset.Icc n_0 N, product_term n := by
    -- Apply the existence of c from the previous step.
    apply M_lower_bound n_0

/-
The sum of 1/a_seq n diverges.
-/
lemma sum_inv_a_seq_diverges (n_0 : ℕ) :
  Filter.Tendsto (fun N => ∑ n ∈ Finset.Icc n_0 N, 1 / a_seq n) Filter.atTop Filter.atTop := by
    -- Since $a_seq n = B_card n - 1$, we have $1/a_seq n \geq 1/B_card n$.
    have h_ge : ∀ n, (1 : ℝ) / a_seq n ≥ (1 : ℝ) / B_card n := by
      intro n;
      gcongr;
      · exact?;
      · exact sub_le_iff_le_add'.mpr ( mod_cast by linarith [ B_card_eq n ] );
    -- Since $\sum_{n=n_0}^N \frac{1}{B_card n}$ diverges, and $\frac{1}{a_seq n} \geq \frac{1}{B_card n}$, it follows that $\sum_{n=n_0}^N \frac{1}{a_seq n}$ also diverges.
    have h_diverge : Filter.Tendsto (fun N => ∑ n ∈ Finset.Icc n_0 N, (1 : ℝ) / B_card n) Filter.atTop Filter.atTop := by
      convert sum_inv_B_card_diverges n_0 using 1;
    exact Filter.tendsto_atTop_mono ( fun N => Finset.sum_le_sum fun _ _ => h_ge _ ) h_diverge

/-
The product of a_n / (a_n + 1/2) tends to 0.
-/
def prod_ratio (n_0 N : ℕ) : ℝ := ∏ n ∈ Finset.Icc n_0 N, a_seq n / product_term n

lemma prod_ratio_tendsto_zero (n_0 : ℕ) :
  Filter.Tendsto (fun N => prod_ratio n_0 N) Filter.atTop (nhds 0) := by
    -- By definition of $prod_ratio$, we have $prod_ratio n_0 N = \prod_{n=n_0}^N \frac{a_n}{a_n + 1/2}$.
    have h_prod_ratio : ∀ N ≥ n_0, prod_ratio n_0 N = ∏ n ∈ Finset.Icc n_0 N, (1 : ℝ) / (1 + 1 / (2 * a_seq n)) := by
      intro N hN; refine Finset.prod_congr rfl fun n hn => ?_; rw [ div_eq_div_iff ] <;> ring <;> norm_num [ a_seq_pos ] ;
      · unfold product_term; rw [ mul_inv_cancel₀ ( ne_of_gt ( a_seq_pos n ) ) ] ; ring;
      · exact ne_of_gt ( add_pos_of_pos_of_nonneg ( a_seq_pos n ) ( by norm_num ) );
      · exact ne_of_gt ( add_pos_of_pos_of_nonneg zero_lt_one ( mul_nonneg ( inv_nonneg.2 ( le_of_lt ( a_seq_pos n ) ) ) ( by norm_num ) ) );
    -- Since $\sum_{n=n_0}^\infty \frac{1}{2a_n}$ diverges, we have $\sum_{n=n_0}^\infty \log(1 + \frac{1}{2a_n})$ also diverges.
    have h_log_diverges : Filter.Tendsto (fun N => ∑ n ∈ Finset.Icc n_0 N, Real.log (1 + 1 / (2 * a_seq n))) Filter.atTop Filter.atTop := by
      -- Since $\sum_{n=n_0}^\infty \frac{1}{2a_n}$ diverges, we can use the comparison test.
      have h_comparison : Filter.Tendsto (fun N => ∑ n ∈ Finset.Icc n_0 N, (1 / (2 * a_seq n) : ℝ)) Filter.atTop Filter.atTop := by
        have h_sum_diverges : Filter.Tendsto (fun N => ∑ n ∈ Finset.Icc n_0 N, (1 : ℝ) / a_seq n) Filter.atTop Filter.atTop := by
          exact?;
        convert h_sum_diverges.const_mul_atTop ( show ( 0 : ℝ ) < 1 / 2 by norm_num ) using 2 ; norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ];
      -- Since $\log(1 + x) \geq \frac{x}{2}$ for $0 < x \leq 1$, we can apply this inequality to each term in the sum.
      have h_log_ineq : ∀ N ≥ n_0, ∑ n ∈ Finset.Icc n_0 N, Real.log (1 + 1 / (2 * a_seq n)) ≥ ∑ n ∈ Finset.Icc n_0 N, (1 / (2 * a_seq n) : ℝ) / 2 := by
        intros N hN
        apply Finset.sum_le_sum
        intro n hn
        have h_log_ineq : Real.log (1 + 1 / (2 * a_seq n)) ≥ (1 / (2 * a_seq n) : ℝ) / 2 := by
          have h_log_ineq : ∀ x : ℝ, 0 < x ∧ x ≤ 1 → Real.log (1 + x) ≥ x / 2 := by
            exact fun x hx => by nlinarith [ Real.log_inv ( 1 + x ), Real.log_le_sub_one_of_pos ( inv_pos.mpr ( by linarith : 0 < 1 + x ) ), mul_inv_cancel₀ ( by linarith : ( 1 + x ) ≠ 0 ) ] ;
          apply h_log_ineq; exact ⟨by
          exact one_div_pos.mpr ( mul_pos zero_lt_two ( a_seq_pos n ) ), by
            rw [ div_le_iff₀ ] <;> norm_num [ a_seq ];
            · exact le_trans ( by norm_num ) ( mul_le_mul_of_nonneg_left ( sub_le_sub_right ( Nat.cast_le.mpr ( show B_card n ≥ 2 from by rw [ show B_card n = 2 ^ ( k n ) - 1 from B_card_eq n ] ; exact Nat.le_sub_one_of_lt ( lt_of_lt_of_le ( by decide ) ( Nat.pow_le_pow_right ( by decide ) ( show k n ≥ 2 from by exact le_add_of_le_of_nonneg ( by decide ) ( Nat.zero_le _ ) ) ) ) ) ) _ ) zero_le_two );
            · rw [ B_card_eq ];
              exact lt_tsub_iff_left.mpr ( lt_of_lt_of_le ( by norm_num ) ( Nat.pow_le_pow_right ( by norm_num ) ( show k n ≥ 2 by exact le_add_of_le_of_nonneg ( by norm_num ) ( Nat.zero_le _ ) ) ) )⟩
        exact h_log_ineq;
      exact Filter.tendsto_atTop_mono ( fun N => if hN : N < n_0 then by aesop else h_log_ineq N ( le_of_not_gt hN ) ) ( by simpa [ Finset.sum_div _ _ _ ] using h_comparison.atTop_div_const ( by norm_num : ( 0 : ℝ ) < 2 ) );
    -- Since $\sum_{n=n_0}^\infty \log(1 + \frac{1}{2a_n})$ diverges, we have $\prod_{n=n_0}^N \frac{1}{1 + \frac{1}{2a_n}}$ tends to $0$.
    have h_prod_zero : Filter.Tendsto (fun N => Real.exp (-∑ n ∈ Finset.Icc n_0 N, Real.log (1 + 1 / (2 * a_seq n)))) Filter.atTop (nhds 0) := by
      aesop;
    refine' h_prod_zero.congr' _;
    filter_upwards [ Filter.eventually_ge_atTop n_0 ] with N hN using by rw [ h_prod_ratio N hN, Real.exp_neg, Real.exp_sum, Finset.prod_congr rfl fun _ _ => Real.exp_log ( by exact add_pos_of_pos_of_nonneg zero_lt_one <| one_div_nonneg.mpr <| mul_nonneg zero_le_two <| le_of_lt <| a_seq_pos _ ) ] ; aesop;

def density_ratio (n_0 N : ℕ) : ℝ := (E_N n_0 N : ℝ) / M (N + 1)

/-
e_k is bounded by (sum)^k / k!.
-/
lemma esymm_le_pow_sum (s : Finset ℕ) (f : ℕ → ℝ) (k : ℕ) (hf : ∀ i ∈ s, 0 ≤ f i) :
  (s.val.map f).esymm k ≤ (∑ i ∈ s, f i) ^ k / k ! := by
    -- By definition of $e_k$, we know that $k! e_k = \sum_{j_1, \dots, j_k \in s} f j_1 \cdots f j_k$.
    have h_esymm : ((s.val.map (fun x => f x)).esymm k) * (Nat.factorial k) ≤ (∑ i ∈ s, f i) ^ k := by
      rw [ Multiset.esymm ];
      rw [ ← Multiset.sum_map_mul_right ];
      -- By definition of $e_k$, we know that $k! e_k = \sum_{j_1, \dots, j_k \in s} f j_1 \cdots f j_k$ and each term in the sum is non-negative.
      have h_esymm : ∀ (s : Multiset ℝ) (k : ℕ), (∀ x ∈ s, 0 ≤ x) → ((Multiset.map (fun i => i.prod * (k ! : ℝ)) (Multiset.powersetCard k s)).sum) ≤ (Multiset.sum s) ^ k := by
        intros s k hs_nonneg
        induction' s using Multiset.induction with x s ih generalizing k;
        · cases k <;> norm_num [ Multiset.powersetCard ];
          · erw [ Quot.liftOn_mk ] ; norm_num;
          · erw [ Quot.liftOn_mk ] ; norm_num;
        · rcases k with ( _ | k ) <;> simp_all +decide [ Multiset.powersetCard_cons ];
          rw [ add_pow ];
          simp_all +decide [ Finset.sum_range_succ', Nat.factorial_succ, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ];
          refine' le_trans ( add_le_add ( _ : _ ≤ _ ) ( _ : _ ≤ _ ) ) _;
          exact s.sum ^ ( k + 1 );
          exact x * ( s.sum ^ k * ( k + 1 ) );
          · convert ih ( k + 1 ) using 1;
            norm_num [ Nat.factorial_succ, mul_assoc, mul_comm, mul_left_comm ];
          · rw [ Multiset.sum_map_mul_left ];
            exact mul_le_mul_of_nonneg_left ( by simpa [ mul_assoc, mul_comm, mul_left_comm, Multiset.sum_map_mul_right ] using mul_le_mul_of_nonneg_left ( ih k ) ( by positivity : 0 ≤ ( k + 1 : ℝ ) ) ) hs_nonneg.1;
          · linarith [ show 0 ≤ ∑ i ∈ Finset.range k, x ^ ( i + 1 + 1 ) * ( s.sum ^ ( k - ( i + 1 ) ) * ( Nat.choose ( k + 1 ) ( i + 1 + 1 ) : ℝ ) ) from Finset.sum_nonneg fun i hi => mul_nonneg ( pow_nonneg hs_nonneg.1 _ ) ( mul_nonneg ( pow_nonneg ( Multiset.sum_nonneg hs_nonneg.2 ) _ ) ( Nat.cast_nonneg _ ) ) ];
      aesop;
    rwa [ le_div_iff₀ ( by positivity ) ]

def bound_ratio (n_0 N : ℕ) : ℝ := symmetric_bound n_0 N / ∏ n ∈ Finset.Icc n_0 N, product_term n

/-
The symmetric bound is bounded by the product of a_n times a polynomial in S_N.
-/
def S_sum (n_0 N : ℕ) : ℝ := ∑ n ∈ Finset.Icc n_0 N, 1 / a_seq n

lemma symmetric_bound_le_poly (n_0 N : ℕ) :
  symmetric_bound n_0 N ≤ (∏ n ∈ Finset.Icc n_0 N, a_seq n) * ∑ j ∈ Finset.range (M n_0), (S_sum n_0 N) ^ j / j ! := by
    refine' mul_le_mul_of_nonneg_left _ ( Finset.prod_nonneg fun _ _ => le_of_lt ( a_seq_pos _ ) );
    gcongr;
    apply_rules [ esymm_le_pow_sum ];
    exact fun _ _ => one_div_nonneg.mpr ( le_of_lt ( a_seq_pos _ ) )

/-
The density ratio E_N / M_{N+1} is bounded by a constant times the product ratio times a polynomial in S_N.
-/
def poly_S (n_0 N : ℕ) : ℝ := ∑ j ∈ Finset.range (M n_0), (S_sum n_0 N) ^ j / j !

def C_val (n_0 : ℕ) : ℝ := (M n_0 + 1 : ℝ) / M n_0

lemma density_ratio_bound (n_0 : ℕ) :
  ∃ c > 0, ∀ N ≥ n_0,
  density_ratio n_0 N ≤ (C_val n_0 / c) * prod_ratio n_0 N * poly_S n_0 N := by
    have := M_lower_bound_proven n_0;
    obtain ⟨ c, hc₀, hc ⟩ := this;
    refine' ⟨ c, hc₀, fun N hN => _ ⟩;
    have h_density_le : density_ratio n_0 N ≤ ((M n_0 + 1) : ℝ) * symmetric_bound n_0 N / (c * M n_0 * ∏ n ∈ Finset.Icc n_0 N, product_term n) := by
      have h_density_le : density_ratio n_0 N ≤ ((M n_0 + 1) : ℝ) * symmetric_bound n_0 N / (M (N + 1)) := by
        unfold density_ratio;
        gcongr;
        have h_density_le : E_N n_0 N ≤ (M n_0 + 1) * symmetric_bound n_0 N := by
          have := @bad_functions_bound n_0 N;
          exact le_trans ( mod_cast E_N_le_bad_functions n_0 N ) ( mul_le_mul_of_nonneg_left this ( by positivity ) );
        convert h_density_le using 1;
      field_simp;
      rw [ le_div_iff₀ ] at *;
      · nlinarith [ hc N hN, show 0 ≤ density_ratio n_0 N by exact div_nonneg ( Nat.cast_nonneg _ ) ( Nat.cast_nonneg _ ) ];
      · exact Nat.cast_pos.mpr ( M_pos _ );
      · exact mul_pos ( Nat.cast_pos.mpr ( M_pos _ ) ) ( Finset.prod_pos fun n hn => add_pos_of_nonneg_of_pos ( le_of_lt ( a_seq_pos _ ) ) ( by norm_num ) );
    have h_symmetric_bound_le : symmetric_bound n_0 N ≤ (∏ n ∈ Finset.Icc n_0 N, a_seq n) * poly_S n_0 N := by
      convert symmetric_bound_le_poly n_0 N using 1;
    convert h_density_le.trans ( div_le_div_of_nonneg_right ( mul_le_mul_of_nonneg_left h_symmetric_bound_le <| by positivity ) <| by exact mul_nonneg ( mul_nonneg hc₀.le <| Nat.cast_nonneg _ ) <| Finset.prod_nonneg fun _ _ => by exact le_of_lt <| show 0 < product_term _ from by exact add_pos_of_nonneg_of_pos ( le_of_lt <| a_seq_pos _ ) <| by positivity ) using 1 ; ring;
    unfold C_val prod_ratio; ring;
    simpa only [ Finset.prod_mul_distrib, Finset.prod_inv_distrib ] using by ring;

/-
We prove a lower bound on a_n.
-/
lemma a_seq_ge_62 (n : ℕ) : a_seq n ≥ 62 := by
  -- We'll use that $k_n \geq 6$ to show that $a_n \geq 62$.
  have h_k_ge_6 : ∀ n, 6 ≤ k n := by
    -- Since $k_n \geq 6$ for all $n$, we have $6 \leq k_n$.
    intros n
    unfold k
    simp [clog2];
    split_ifs <;> simp_all +arith +decide;
    · exact absurd ‹_› ( by exact Nat.ne_of_gt ( Nat.recOn n ( by native_decide ) fun n ihn => by cases n <;> trivial ) );
    · rw [ Nat.le_log2 ] <;> norm_num;
      · rw [ Nat.le_log2 ] <;> norm_num;
      · assumption;
  unfold a_seq;
  rw [ show B_card n = 2 ^ ( k n ) - 1 from B_card_eq n ];
  exact le_tsub_of_add_le_left ( mod_cast Nat.le_sub_one_of_lt ( lt_of_lt_of_le ( by decide ) ( Nat.pow_le_pow_right ( by decide ) ( h_k_ge_6 n ) ) ) )

/-
We prove a logarithmic inequality for the terms in the product.
-/
lemma log_ineq (n : ℕ) : Real.log (a_seq n / product_term n) ≤ -1 / (4 * a_seq n) := by
  -- Let $y = 1/(2*a_n)$. We need log(1+y) >= y/2.
  set y : ℝ := 1 / (2 * a_seq n)
  have h_log_y : Real.log (1 + y) ≥ y / 2 := by
    -- Since $a_n \geq 62$, we have $y \leq 1/124$.
    have hy_le : y ≤ 1 / 124 := by
      exact one_div_le_one_div_of_le ( by norm_num ) ( by linarith [ a_seq_ge_62 n ] );
    nlinarith [ Real.log_inv ( 1 + y ), Real.log_le_sub_one_of_pos ( inv_pos.mpr ( by linarith [ show 0 < y from one_div_pos.mpr ( mul_pos zero_lt_two ( a_seq_pos n ) ) ] : 0 < ( 1 + y ) ) ), mul_inv_cancel₀ ( by linarith [ show 0 < y from one_div_pos.mpr ( mul_pos zero_lt_two ( a_seq_pos n ) ) ] : ( 1 + y ) ≠ 0 ), show 0 < y from one_div_pos.mpr ( mul_pos zero_lt_two ( a_seq_pos n ) ) ];
  -- Substitute y = 1/(2*a_n) into the inequality.
  have h_sub : Real.log (1 / (1 + y)) ≤ -y / 2 := by
    norm_num at * ; linarith;
  convert h_sub using 1 <;> norm_num [ y, product_term ] ; ring;
  · rw [ ← Real.log_inv ] ; ring;
    field_simp;
    rw [ show a_seq n * 2 / ( 1 + a_seq n * 2 ) = 2 / ( 2 + 1 / a_seq n ) by rw [ div_eq_div_iff ] <;> nlinarith [ a_seq_pos n, one_div_mul_cancel ( ne_of_gt ( a_seq_pos n ) ) ] ];
  · ring

/-
We prove an exponential bound on the product ratio.
-/
lemma prod_ratio_bound (n_0 N : ℕ) : prod_ratio n_0 N ≤ Real.exp (- S_sum n_0 N / 4) := by
  -- Apply the inequality term by term to the product.
  have h_prod_le_exp : ∏ n ∈ Finset.Icc n_0 N, (a_seq n / product_term n) ≤ Real.exp (∑ x ∈ Finset.Icc n_0 N, Real.log (a_seq x / product_term x)) := by
    rw [ Real.exp_sum, Finset.prod_congr rfl fun _ _ => Real.exp_log ( _ ) ];
    exact fun x hx => div_pos ( a_seq_pos x ) ( add_pos ( a_seq_pos x ) ( by norm_num ) );
  -- Apply the inequality term by term to the sum.
  have h_sum_le_exp : ∑ x ∈ Finset.Icc n_0 N, Real.log (a_seq x / product_term x) ≤ -S_sum n_0 N / 4 := by
    exact le_trans ( Finset.sum_le_sum fun i hi => log_ineq i ) ( by simp +decide [ div_eq_mul_inv, Finset.mul_sum _ _ _, mul_assoc, mul_comm, mul_left_comm, S_sum ] );
  exact h_prod_le_exp.trans ( Real.exp_le_exp.mpr h_sum_le_exp )

/-
The sum S_N diverges to infinity.
-/
lemma S_sum_diverges (n_0 : ℕ) :
  Filter.Tendsto (fun N => S_sum n_0 N) Filter.atTop Filter.atTop := by
    convert sum_inv_a_seq_diverges n_0 using 1

/-
The product of the ratio and the polynomial tends to 0.
-/
lemma main_bound_tendsto_zero (n_0 : ℕ) :
  Filter.Tendsto (fun N => prod_ratio n_0 N * poly_S n_0 N) Filter.atTop (nhds 0) := by
    have h_term : ∀ j < M n_0, Filter.Tendsto (fun N => (S_sum n_0 N)^j * Real.exp (-S_sum n_0 N / 4)) Filter.atTop (nhds 0) := by
      -- Let $y = S_sum$. We need to show that $y^j e^{-y/4} \to 0$ as $y \to \infty$.
      intro j hj
      suffices h_y : Filter.Tendsto (fun y : ℝ => y^j * Real.exp (-y / 4)) Filter.atTop (nhds 0) by
        exact h_y.comp ( S_sum_diverges n_0 );
      -- Let $z = \frac{y}{4}$, so we can rewrite the limit as $\lim_{z \to \infty} (4z)^j e^{-z}$.
      suffices h_z : Filter.Tendsto (fun z : ℝ => (4 * z)^j * Real.exp (-z)) Filter.atTop (nhds 0) by
        convert h_z.comp ( Filter.tendsto_id.atTop_mul_const ( by norm_num : 0 < ( 4 : ℝ ) ⁻¹ ) ) using 2 ; norm_num ; ring;
      have := Real.tendsto_pow_mul_exp_neg_atTop_nhds_zero;
      convert this j |> Filter.Tendsto.const_mul ( 4 ^ j ) using 2 <;> ring;
    have h_sum : Filter.Tendsto (fun N => ∑ j ∈ Finset.range (M n_0), (S_sum n_0 N)^j * Real.exp (-S_sum n_0 N / 4) / j !) Filter.atTop (nhds (∑ j ∈ Finset.range (M n_0), 0 / j !)) := by
      exact tendsto_finset_sum _ fun j hj => by simpa using h_term j ( Finset.mem_range.mp hj ) |> Filter.Tendsto.div_const <| j !;
    simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_mul ];
    refine' squeeze_zero ( fun N => _ ) ( fun N => _ ) h_sum;
    · exact mul_nonneg ( Finset.sum_nonneg fun _ _ => div_nonneg ( pow_nonneg ( Finset.sum_nonneg fun _ _ => one_div_nonneg.mpr ( show 0 ≤ a_seq _ from le_of_lt ( a_seq_pos _ ) ) ) _ ) ( Nat.cast_nonneg _ ) ) ( Finset.prod_nonneg fun _ _ => div_nonneg ( show 0 ≤ a_seq _ from le_of_lt ( a_seq_pos _ ) ) ( show 0 ≤ product_term _ from add_nonneg ( le_of_lt ( a_seq_pos _ ) ) ( by norm_num ) ) );
    · refine' le_trans ( mul_le_mul_of_nonneg_left ( prod_ratio_bound n_0 N ) ( _ ) ) _;
      · exact Finset.sum_nonneg fun _ _ => div_nonneg ( pow_nonneg ( Finset.sum_nonneg fun _ _ => one_div_nonneg.mpr ( le_of_lt ( a_seq_pos _ ) ) ) _ ) ( Nat.cast_nonneg _ );
      · unfold poly_S; norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ] ;

/-
The density ratio tends to 0.
-/
lemma density_ratio_tendsto_zero (n_0 : ℕ) :
  Filter.Tendsto (fun N => density_ratio n_0 N) Filter.atTop (nhds 0) := by
    -- By the density ratio bound, there exists a constant c such that density_ratio n_0 N ≤ c * prod_ratio n_0 N * poly_S n_0 N.
    obtain ⟨c, hc_pos, hc_bound⟩ := density_ratio_bound n_0;
    -- Since $prod\_ratio \cdot poly\_S \to 0$, multiplying by a constant $C\_val / c$ preserves the limit.
    have h_const_mul : Filter.Tendsto (fun N => (C_val n_0 / c) * prod_ratio n_0 N * poly_S n_0 N) Filter.atTop (nhds 0) := by
      simpa [ mul_assoc ] using Filter.Tendsto.const_mul ( C_val n_0 / c ) ( main_bound_tendsto_zero n_0 );
    exact squeeze_zero_norm' ( Filter.eventually_atTop.mpr ⟨ n_0, fun N hN => by rw [ Real.norm_of_nonneg ( by exact div_nonneg ( Nat.cast_nonneg _ ) ( Nat.cast_nonneg _ ) ) ] ; exact hc_bound N hN ⟩ ) h_const_mul

/-
M_{n+1} is bounded by (a_n + 1) * M_n.
-/
lemma M_ratio_upper_bound (n : ℕ) : (M (n + 1) : ℝ) ≤ (a_seq n + 1) * M n := by
  norm_num [ Nat.floor_le, a_seq ];
  rw_mod_cast [ B_card_eq ];
  have h_M_succ : M (n + 1) = (M n * (2^(k n + 1) - 3)) / 2 := by
    rfl;
  rw [ h_M_succ, Nat.div_le_iff_le_mul_add_pred ] <;> norm_num;
  norm_num [ pow_succ' ] ; ring_nf;
  nlinarith [ Nat.sub_add_cancel ( show 3 ≤ 2 ^ k n * 2 from by linarith [ Nat.pow_le_pow_right two_pos ( show k n ≥ 1 from Nat.one_le_iff_ne_zero.mpr ( by unfold k; aesop ) ) ] ), Nat.sub_add_cancel ( show 1 ≤ 2 ^ k n from Nat.one_le_pow _ _ zero_lt_two ) ]

/-
We prove an upper bound on a_n using log base 2.
-/
lemma a_seq_le_log (n : ℕ) : a_seq n ≤ 32 * Real.logb 2 (n + 16) := by
  -- We'll use that $k_n \leq 5 + \log_2(\log_2(n+16))$ to bound $a_n$.
  have h_k_bound : k n ≤ 5 + Real.logb 2 (Real.logb 2 (n + 16)) := by
    unfold k clog2;
    split_ifs <;> norm_num;
    · grind;
    · linarith;
    · exact le_add_of_le_of_nonneg ( by norm_num ) ( Real.logb_nonneg ( by norm_num ) ( by rw [ Real.le_logb_iff_rpow_le ] <;> norm_num <;> linarith ) );
    · -- We'll use that $Real.logb 2 (Real.logb 2 (↑n + 16)) ≥ Real.logb 2 (↑(Nat.log2 (n + 15)))$.
      have h_logb : Real.logb 2 (Real.logb 2 (↑n + 16)) ≥ Real.logb 2 (↑(Nat.log2 (n + 15))) := by
        gcongr <;> norm_cast;
        · grind;
        · rw [ Real.le_logb_iff_rpow_le ] <;> norm_cast;
          · -- By definition of logarithm, we know that $2^{\log_2(n+15)} \leq n+15$.
            have h_log : 2 ^ (Nat.log2 (n + 15)) ≤ n + 15 := by
              rw [ ← Nat.le_log2 ] ; norm_num;
            linarith;
          · linarith;
      have h_logb : Real.logb 2 (↑(Nat.log2 (n + 15))) ≥ ↑(Nat.log2 (Nat.log2 (n + 15))) := by
        rw [ ge_iff_le, Real.le_logb_iff_rpow_le ] <;> norm_cast;
        · rw [ ← Nat.le_log2 ] ; aesop;
        · exact Nat.pos_of_ne_zero ( by aesop );
      linarith;
  unfold a_seq;
  have h_exp_bound : (B_card n : ℝ) ≤ 2^(k n : ℝ) := by
    norm_num [ B_card_eq ];
  -- Substitute the bound for $k_n$ into the exponential bound.
  have h_exp_bound_subst : (B_card n : ℝ) ≤ 2^5 * 2^(Real.logb 2 (Real.logb 2 (n + 16))) := by
    exact h_exp_bound.trans ( by rw [ ← Real.rpow_natCast, ← Real.rpow_add ( by norm_num ) ] ; exact Real.rpow_le_rpow_of_exponent_le ( by norm_num ) h_k_bound );
  rw [ Real.rpow_logb ] at h_exp_bound_subst <;> nlinarith [ show 1 ≤ Real.logb 2 ( n + 16 ) from by rw [ Real.le_logb_iff_rpow_le ] <;> norm_cast <;> linarith ]

/-
The sequence a_seq is monotone.
-/
lemma a_seq_mono : Monotone a_seq := by
  -- To prove monotonicity, we show that $k_n$ is non-decreasing.
  have h_k_mono : Monotone k := by
    intro n m hnm;
    unfold k;
    unfold clog2;
    split_ifs <;> norm_num;
    all_goals norm_cast at *;
    rw [ Nat.le_log2 ];
    · rw [ Nat.le_log2 ] <;> norm_num;
      refine' le_trans _ ( Nat.add_le_add_right hnm 15 );
      rw [ ← Nat.le_log2 ] <;> norm_num;
      rw [ ← Nat.le_log2 ] ; norm_num;
      grind;
    · aesop;
  refine' fun m n mn => _;
  unfold a_seq;
  simp +decide [ B_card_eq ];
  exact pow_le_pow_right₀ ( by norm_num ) ( h_k_mono mn )

/-
The ratio of exceptions to M_N is bounded by the density ratio times (a_N + 1).
-/
lemma density_ratio_lower_bound_ineq (n_0 N : ℕ) :
  (E_N n_0 N : ℝ) / M N ≤ density_ratio n_0 N * (a_seq N + 1) := by
    -- By definition of density_ratio, we have density_ratio n_0 N = E_N n_0 N / M (N + 1).
    have h_density_ratio : density_ratio n_0 N = (E_N n_0 N : ℝ) / (M (N + 1) : ℝ) := by
      rfl;
    rw [ h_density_ratio, div_mul_eq_mul_div, div_le_div_iff₀ ];
    · rw [ mul_assoc ];
      exact mul_le_mul_of_nonneg_left ( mod_cast M_ratio_upper_bound N ) ( Nat.cast_nonneg _ );
    · exact Nat.cast_pos.mpr ( M_pos _ );
    · exact Nat.cast_pos.mpr ( M_pos _ )

/-
The product of the polynomial in S_sum and a decaying exponential tends to 0.
-/
lemma poly_S_mul_exp_neg_tendsto_zero (n_0 : ℕ) :
  Filter.Tendsto (fun N => poly_S n_0 N * Real.exp (- S_sum n_0 N / 8)) Filter.atTop (nhds 0) := by
    -- Since $S_sum n_0 N$ tends to infinity, for any fixed $j$, the term $(S_sum n_0 N)^j / j! * \exp(-S_sum n_0 N / 8)$ tends to 0.
    have h_term_zero : ∀ j : ℕ, Filter.Tendsto (fun N => (S_sum n_0 N)^j / j ! * Real.exp (-S_sum n_0 N / 8)) Filter.atTop (nhds 0) := by
      intro j
      have h_term_zero_aux : Filter.Tendsto (fun x : ℝ => x^j / j ! * Real.exp (-x / 8)) Filter.atTop (nhds 0) := by
        -- Let $y = \frac{x}{8}$, so we can rewrite the limit as $\lim_{y \to \infty} \frac{(8y)^j}{j!} e^{-y}$.
        suffices h_y : Filter.Tendsto (fun y : ℝ => (8 * y) ^ j / (Nat.factorial j) * Real.exp (-y)) Filter.atTop (nhds 0) by
          convert h_y.comp ( Filter.tendsto_id.atTop_mul_const ( show ( 0 : ℝ ) < 1 / 8 by norm_num ) ) using 2 ; norm_num ; ring;
        -- We can factor out $y^j$ and use the fact that $\exp(-y)$ tends to $0$ faster than any polynomial grows.
        suffices h_factor : Filter.Tendsto (fun y : ℝ => y^j * Real.exp (-y)) Filter.atTop (nhds 0) by
          convert h_factor.const_mul ( 8 ^ j / ( j ! : ℝ ) ) using 2 <;> ring;
        exact ( Real.tendsto_pow_mul_exp_neg_atTop_nhds_zero j );
      exact h_term_zero_aux.comp ( S_sum_diverges n_0 );
    convert tendsto_finset_sum _ fun j ( hj : j ∈ Finset.range ( M n_0 ) ) => h_term_zero j using 2 <;> norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_mul ];
    unfold poly_S; ring;
    rw [ Finset.sum_mul ] ; exact Finset.sum_congr rfl fun _ _ => by ring;

/-
S_sum * a_seq is bounded below by N - n_0 + 1.
-/
lemma S_sum_mul_a_seq_ge (n_0 N : ℕ) (h : n_0 ≤ N) :
  S_sum n_0 N * a_seq N ≥ N - n_0 + 1 := by
    -- Since $a_seq$ is monotone, we have $S_sum \geq \sum_{k=n_0}^N \frac{1}{a_seq N}$.
    have h_S_sum_ge : S_sum n_0 N ≥ ∑ k ∈ Finset.Icc n_0 N, (1 / a_seq N : ℝ) := by
      exact Finset.sum_le_sum fun i hi => one_div_le_one_div_of_le ( by exact lt_of_lt_of_le ( by norm_num ) ( a_seq_ge_62 i ) ) ( a_seq_mono <| Finset.mem_Icc.mp hi |>.2 );
    norm_num at *;
    rw [ Nat.cast_sub ( by linarith ) ] at h_S_sum_ge ; push_cast at * ; nlinarith [ inv_mul_cancel₀ ( show ( a_seq N : ℝ ) ≠ 0 from ne_of_gt <| a_seq_pos N ), a_seq_pos N ]

/-
The product of (a_N + 1) and exp(-S_N/8) tends to 0.
-/
lemma a_seq_mul_exp_neg_S_sum_tendsto_zero (n_0 : ℕ) :
  Filter.Tendsto (fun N => (a_seq N + 1) * Real.exp (- S_sum n_0 N / 8)) Filter.atTop (nhds 0) := by
    -- We'll use that exponential functions grow faster than polynomial functions.
    have h_exp_growth : Filter.Tendsto (fun N => Real.log (a_seq N + 1) - (N - n_0 + 1) / (256 * Real.log (N + 16) / Real.log 2)) Filter.atTop Filter.atBot := by
      -- We'll use that $a_seq N \leq 32 * \log_2(N + 16)$ to bound the logarithm.
      have h_log_bound : ∀ N ≥ n_0, Real.log (a_seq N + 1) ≤ Real.log (32 * Real.log (N + 16) / Real.log 2 + 1) := by
        intro N hN
        have h_a_seq_le : a_seq N ≤ 32 * Real.log (N + 16) / Real.log 2 := by
          convert a_seq_le_log N using 1 ; norm_num [ Real.logb ] ; ring;
        exact Real.log_le_log ( add_pos_of_nonneg_of_pos ( le_of_lt ( a_seq_pos N ) ) zero_lt_one ) ( add_le_add_right h_a_seq_le _ );
      -- We'll use that $Real.log (32 * Real.log (N + 16) / Real.log 2 + 1)$ grows slower than $N / Real.log N$.
      have h_log_growth : Filter.Tendsto (fun N => Real.log (32 * Real.log (N + 16) / Real.log 2 + 1) - (N - n_0 + 1) / (256 * Real.log (N + 16) / Real.log 2)) Filter.atTop Filter.atBot := by
        -- We'll use that $Real.log (32 * Real.log (N + 16) / Real.log 2 + 1)$ grows slower than $N / Real.log N$ to show the limit is $-∞$.
        have h_log_growth : Filter.Tendsto (fun N => Real.log (32 * Real.log (N + 16) / Real.log 2 + 1) / Real.log (N + 16)) Filter.atTop (nhds (0 : ℝ)) := by
          -- We can use the fact that $\log(a \log(N + 16) + 1) / \log(N + 16)$ tends to $0$ as $N$ tends to infinity.
          have h_log_div_log : Filter.Tendsto (fun N => Real.log (32 * Real.log (N + 16) / Real.log 2 + 1) / Real.log (N + 16)) Filter.atTop (nhds 0) := by
            have : Filter.Tendsto (fun N => Real.log (32 * Real.log (N + 16) / Real.log 2 + 1) / Real.log (N + 16)) Filter.atTop (nhds (0)) := by
              have : Filter.Tendsto (fun N => Real.log (32 * Real.log (N + 16) / Real.log 2) / Real.log (N + 16)) Filter.atTop (nhds (0)) := by
                have : Filter.Tendsto (fun N => (Real.log 32 + Real.log (Real.log (N + 16)) - Real.log (Real.log 2)) / Real.log (N + 16)) Filter.atTop (nhds 0) := by
                  -- We'll use the fact that $\frac{\log(\log(N+16))}{\log(N+16)}$ tends to $0$ as $N$ tends to infinity.
                  have h_log_log : Filter.Tendsto (fun N => Real.log (Real.log (N + 16)) / Real.log (N + 16)) Filter.atTop (nhds 0) := by
                    -- Let $y = \log(N + 16)$, so we can rewrite the limit as $\lim_{y \to \infty} \frac{\log(y)}{y}$.
                    suffices h_log_y : Filter.Tendsto (fun y => Real.log y / y) Filter.atTop (nhds 0) by
                      exact h_log_y.comp ( Real.tendsto_log_atTop.comp <| Filter.tendsto_id.atTop_add tendsto_const_nhds );
                    -- Let $z = \frac{1}{y}$, so we can rewrite the limit as $\lim_{z \to 0^+} z \log(1/z)$.
                    suffices h_log_recip : Filter.Tendsto (fun z => z * Real.log (1 / z)) (Filter.map (fun y => 1 / y) Filter.atTop) (nhds 0) by
                      exact h_log_recip.congr ( by simp +contextual [ div_eq_inv_mul ] );
                    norm_num +zetaDelta at *;
                    exact tendsto_nhdsWithin_of_tendsto_nhds ( by simpa using Real.continuous_mul_log.neg.tendsto 0 );
                  simpa [ add_div, sub_div ] using Filter.Tendsto.add ( Filter.Tendsto.add ( tendsto_const_nhds.mul ( tendsto_inv_atTop_zero.comp ( Real.tendsto_log_atTop.comp ( Filter.tendsto_id.atTop_add tendsto_const_nhds ) ) ) ) h_log_log ) ( Filter.Tendsto.neg ( tendsto_const_nhds.mul ( tendsto_inv_atTop_zero.comp ( Real.tendsto_log_atTop.comp ( Filter.tendsto_id.atTop_add tendsto_const_nhds ) ) ) ) );
                refine' this.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with N hN using by rw [ Real.log_div ( by exact ne_of_gt ( mul_pos ( by norm_num ) ( Real.log_pos ( by linarith ) ) ) ) ( by positivity ), Real.log_mul ( by norm_num ) ( by exact ne_of_gt ( Real.log_pos ( by linarith ) ) ) ] )
              have : Filter.Tendsto (fun N => (Real.log (32 * Real.log (N + 16) / Real.log 2 + 1) - Real.log (32 * Real.log (N + 16) / Real.log 2)) / Real.log (N + 16)) Filter.atTop (nhds 0) := by
                have : Filter.Tendsto (fun N => Real.log (1 + 1 / (32 * Real.log (N + 16) / Real.log 2)) / Real.log (N + 16)) Filter.atTop (nhds 0) := by
                  exact le_trans ( Filter.Tendsto.div_atTop ( Filter.Tendsto.log ( tendsto_const_nhds.add <| tendsto_const_nhds.div_atTop <| Filter.Tendsto.atTop_div_const ( by positivity ) <| Filter.Tendsto.const_mul_atTop ( by positivity ) <| Real.tendsto_log_atTop.comp <| Filter.tendsto_id.atTop_add tendsto_const_nhds ) <| by positivity ) <| Real.tendsto_log_atTop.comp <| Filter.tendsto_id.atTop_add tendsto_const_nhds ) <| by norm_num;
                refine' this.congr' _;
                filter_upwards [ Filter.eventually_gt_atTop 0 ] with N hN using by rw [ one_add_div ( by exact ne_of_gt ( div_pos ( mul_pos ( by norm_num ) ( Real.log_pos ( by linarith ) ) ) ( Real.log_pos ( by norm_num ) ) ) ), Real.log_div ( by exact ne_of_gt ( add_pos ( div_pos ( mul_pos ( by norm_num ) ( Real.log_pos ( by linarith ) ) ) ( Real.log_pos ( by norm_num ) ) ) zero_lt_one ) ) ( by exact ne_of_gt ( div_pos ( mul_pos ( by norm_num ) ( Real.log_pos ( by linarith ) ) ) ( Real.log_pos ( by norm_num ) ) ) ) ] ;
              convert this.add ‹Filter.Tendsto ( fun N => Real.log ( 32 * Real.log ( N + 16 ) / Real.log 2 ) / Real.log ( N + 16 ) ) Filter.atTop ( nhds 0 ) › using 2 <;> ring
            exact this;
          convert h_log_div_log using 1;
        -- We'll use that $N / \log N$ grows faster than $Real.log (32 * Real.log (N + 16) / Real.log 2 + 1)$.
        have h_div_growth : Filter.Tendsto (fun N => (N - n_0 + 1) / (256 * Real.log (N + 16) / Real.log 2) / Real.log (N + 16)) Filter.atTop Filter.atTop := by
          -- We can simplify the expression inside the limit.
          suffices h_simplified : Filter.Tendsto (fun N => (N - n_0 + 1) / (Real.log (N + 16) ^ 2)) Filter.atTop Filter.atTop by
            convert h_simplified.const_mul_atTop ( show 0 < Real.log 2 / 256 by positivity ) using 2 ; ring;
            norm_num ; ring;
          -- We can use the change of variables $u = \log(N + 16)$ to simplify the expression.
          suffices h_change : Filter.Tendsto (fun u => (Real.exp u - n_0 - 15) / u^2) Filter.atTop Filter.atTop by
            have h_change : Filter.Tendsto (fun N => (Real.exp (Real.log (N + 16)) - n_0 - 15) / (Real.log (N + 16))^2) Filter.atTop Filter.atTop := by
              exact h_change.comp ( Real.tendsto_log_atTop.comp <| Filter.tendsto_id.atTop_add tendsto_const_nhds );
            refine h_change.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with N hN using by rw [ Real.exp_log ( by linarith ) ] ; ring );
          -- We can use the fact that $\exp(u) / u^2$ tends to infinity as $u$ tends to infinity.
          have h_exp_div_u2 : Filter.Tendsto (fun u => Real.exp u / u^2) Filter.atTop Filter.atTop := by
            exact Real.tendsto_exp_div_pow_atTop 2;
          simp_all +decide [ sub_div ];
          exact Filter.Tendsto.atTop_add ( Filter.Tendsto.atTop_add h_exp_div_u2 ( Filter.Tendsto.neg ( tendsto_const_nhds.div_atTop ( by norm_num ) ) ) ) ( Filter.Tendsto.neg ( tendsto_const_nhds.div_atTop ( by norm_num ) ) );
        have h_combined : Filter.Tendsto (fun N => Real.log (32 * Real.log (N + 16) / Real.log 2 + 1) / Real.log (N + 16) - (N - n_0 + 1) / (256 * Real.log (N + 16) / Real.log 2) / Real.log (N + 16)) Filter.atTop Filter.atBot := by
          exact Filter.Tendsto.add_atBot h_log_growth ( Filter.tendsto_neg_atTop_atBot.comp h_div_growth );
        have h_combined : Filter.Tendsto (fun N => (Real.log (32 * Real.log (N + 16) / Real.log 2 + 1) - (N - n_0 + 1) / (256 * Real.log (N + 16) / Real.log 2)) / Real.log (N + 16)) Filter.atTop Filter.atBot := by
          simpa only [ sub_div ] using h_combined;
        have h_combined : Filter.Tendsto (fun N => (Real.log (32 * Real.log (N + 16) / Real.log 2 + 1) - (N - n_0 + 1) / (256 * Real.log (N + 16) / Real.log 2)) / Real.log (N + 16) * Real.log (N + 16)) Filter.atTop Filter.atBot := by
          apply Filter.Tendsto.atBot_mul_atTop₀;
          · convert h_combined using 1;
          · exact Real.tendsto_log_atTop.comp <| Filter.tendsto_id.atTop_add tendsto_const_nhds;
        refine h_combined.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with N hN using by rw [ div_mul_cancel₀ _ ( ne_of_gt ( Real.log_pos ( by linarith ) ) ) ] );
      rw [ Filter.tendsto_atTop_atBot ] at *;
      exact fun b => by obtain ⟨ i, hi ⟩ := h_log_growth b; exact ⟨ ⌈i⌉₊ + n_0, fun a ha => le_trans ( sub_le_sub_right ( h_log_bound a ( by linarith ) ) _ ) ( hi a ( Nat.le_of_ceil_le ( by linarith ) ) ) ⟩ ;
    have h_exp_growth : Filter.Tendsto (fun N => Real.log ((a_seq N + 1) * Real.exp (-S_sum n_0 N / 8))) Filter.atTop Filter.atBot := by
      have h_exp_growth : ∀ N ≥ n_0, Real.log ((a_seq N + 1) * Real.exp (-S_sum n_0 N / 8)) ≤ Real.log (a_seq N + 1) - (N - n_0 + 1) / (256 * Real.log (N + 16) / Real.log 2) := by
        intros N hN
        have h_exp_growth : -S_sum n_0 N / 8 ≤ -(N - n_0 + 1) / (256 * Real.log (N + 16) / Real.log 2) := by
          have h_exp_growth : S_sum n_0 N ≥ (N - n_0 + 1) / a_seq N := by
            have := S_sum_mul_a_seq_ge n_0 N hN;
            exact div_le_iff₀ ( show 0 < a_seq N from a_seq_pos N ) |>.2 this;
          have h_exp_growth : a_seq N ≤ 32 * Real.log (N + 16) / Real.log 2 := by
            convert a_seq_le_log N using 1;
            rw [ Real.logb, mul_div_assoc ];
          have h_exp_growth : (N - n_0 + 1) / a_seq N ≥ (N - n_0 + 1) / (32 * Real.log (N + 16) / Real.log 2) := by
            gcongr;
            · linarith [ show ( N : ℝ ) ≥ n_0 by norm_cast ];
            · exact a_seq_pos N;
          ring_nf at *; linarith;
        rw [ Real.log_mul ( by exact ne_of_gt ( add_pos_of_nonneg_of_pos ( le_of_lt ( a_seq_pos N ) ) zero_lt_one ) ) ( by positivity ), Real.log_exp ] ; ring_nf at * ; linarith;
      rw [ Filter.tendsto_atTop_atBot ] at *;
      exact fun b => by obtain ⟨ i, hi ⟩ := ‹∀ b : ℝ, ∃ i : ℕ, ∀ a : ℕ, i ≤ a → Real.log ( a_seq a + 1 ) - ( a - n_0 + 1 ) / ( 256 * Real.log ( a + 16 ) / Real.log 2 ) ≤ b› b; exact ⟨ Max.max i n_0, fun a ha => le_trans ( h_exp_growth a ( le_trans ( le_max_right _ _ ) ha ) ) ( hi a ( le_trans ( le_max_left _ _ ) ha ) ) ⟩ ;
    have h_exp_growth : Filter.Tendsto (fun N => Real.exp (Real.log ((a_seq N + 1) * Real.exp (-S_sum n_0 N / 8)))) Filter.atTop (nhds 0) := by
      aesop;
    exact h_exp_growth.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with N hN using by rw [ Real.exp_log ( mul_pos ( add_pos_of_nonneg_of_pos ( le_of_lt ( a_seq_pos N ) ) zero_lt_one ) ( Real.exp_pos _ ) ) ] )

/-
The ratio of exceptions to M_N tends to 0.
-/
lemma density_ratio_lower_tendsto_zero (n_0 : ℕ) :
  Filter.Tendsto (fun N => (E_N n_0 N : ℝ) / M N) Filter.atTop (nhds 0) := by
    -- By Lemma 26, $E_N / M_N \leq K * prod_ratio * poly_S * (a_N + 1)$
    have h_bound : ∃ K > 0, ∀ N ≥ n_0, (E_N n_0 N : ℝ) / M N ≤ K * prod_ratio n_0 N * poly_S n_0 N * (a_seq N + 1) := by
      -- By Lemma 26, $E_N / M_N \leq density_ratio * (a_N + 1)$
      have h_bound : ∀ N ≥ n_0, (E_N n_0 N : ℝ) / M N ≤ density_ratio n_0 N * (a_seq N + 1) := by
        exact?;
      obtain ⟨ K, hK ⟩ := density_ratio_bound n_0;
      exact ⟨ C_val n_0 / K, div_pos ( show 0 < C_val n_0 by exact div_pos ( add_pos_of_nonneg_of_pos ( Nat.cast_nonneg _ ) zero_lt_one ) ( Nat.cast_pos.mpr ( M_pos _ ) ) ) hK.1, fun N hN => le_trans ( h_bound N hN ) ( by nlinarith [ hK.2 N hN, show 0 ≤ a_seq N + 1 by exact add_nonneg ( le_of_lt ( a_seq_pos _ ) ) zero_le_one ] ) ⟩;
    -- By Lemma 27, $poly_S * exp(-S_sum/8) * (a_N + 1) * exp(-S_sum/8)$ tends to 0.
    have h_prod_tendsto_zero : Filter.Tendsto (fun N => prod_ratio n_0 N * poly_S n_0 N * (a_seq N + 1)) Filter.atTop (nhds 0) := by
      -- By Lemma 27, $poly_S * exp(-S_sum/8) * (a_N + 1) * exp(-S_sum/8)$ tends to 0 as $N$ tends to infinity.
      have h_prod_tendsto_zero : Filter.Tendsto (fun N => poly_S n_0 N * Real.exp (- S_sum n_0 N / 8) * (a_seq N + 1) * Real.exp (- S_sum n_0 N / 8)) Filter.atTop (nhds 0) := by
        simpa [ mul_assoc ] using Filter.Tendsto.mul ( poly_S_mul_exp_neg_tendsto_zero n_0 ) ( a_seq_mul_exp_neg_S_sum_tendsto_zero n_0 );
      -- Since $prod_ratio \leq \exp(-S_sum/4)$, we have $prod_ratio * poly_S * (a_N + 1) \leq \exp(-S_sum/4) * poly_S * (a_N + 1)$.
      have h_prod_le_exp : ∀ N ≥ n_0, prod_ratio n_0 N * poly_S n_0 N * (a_seq N + 1) ≤ Real.exp (- S_sum n_0 N / 4) * poly_S n_0 N * (a_seq N + 1) := by
        intros N hN
        have h_prod_le_exp : prod_ratio n_0 N ≤ Real.exp (- S_sum n_0 N / 4) := by
          convert prod_ratio_bound n_0 N using 1
        exact mul_le_mul_of_nonneg_right (mul_le_mul_of_nonneg_right h_prod_le_exp (by
        exact Finset.sum_nonneg fun _ _ => div_nonneg ( pow_nonneg ( Finset.sum_nonneg fun _ _ => one_div_nonneg.mpr ( show 0 ≤ a_seq _ from le_of_lt ( a_seq_pos _ ) ) ) _ ) ( Nat.cast_nonneg _ ))) (by
        exact add_nonneg ( le_of_lt ( a_seq_pos N ) ) zero_le_one);
      -- Since $Real.exp (- S_sum n_0 N / 4) \leq Real.exp (- S_sum n_0 N / 8) * Real.exp (- S_sum n_0 N / 8)$, we can bound the product.
      have h_exp_bound : ∀ N ≥ n_0, Real.exp (- S_sum n_0 N / 4) * poly_S n_0 N * (a_seq N + 1) ≤ Real.exp (- S_sum n_0 N / 8) * Real.exp (- S_sum n_0 N / 8) * poly_S n_0 N * (a_seq N + 1) := by
        exact fun N hN => by rw [ ← Real.exp_add ] ; ring_nf; norm_num;
      refine' squeeze_zero_norm' _ h_prod_tendsto_zero;
      filter_upwards [ Filter.eventually_ge_atTop n_0 ] with N hN using by rw [ Real.norm_of_nonneg ( by exact mul_nonneg ( mul_nonneg ( Finset.prod_nonneg fun _ _ => div_nonneg ( by exact le_of_lt ( by exact a_seq_pos _ ) ) ( by exact add_nonneg ( by exact le_of_lt ( by exact a_seq_pos _ ) ) ( by norm_num ) ) ) ( Finset.sum_nonneg fun _ _ => div_nonneg ( pow_nonneg ( Finset.sum_nonneg fun _ _ => one_div_nonneg.mpr ( by exact le_of_lt ( by exact a_seq_pos _ ) ) ) _ ) ( Nat.cast_nonneg _ ) ) ) ( by exact add_nonneg ( by exact le_of_lt ( by exact a_seq_pos _ ) ) zero_le_one ) ) ] ; linarith [ h_prod_le_exp N hN, h_exp_bound N hN ] ;
    refine' squeeze_zero_norm' _ ( by simpa using h_prod_tendsto_zero.const_mul h_bound.choose );
    filter_upwards [ Filter.eventually_ge_atTop n_0 ] with N hN using by rw [ Real.norm_of_nonneg ( by positivity ) ] ; linarith [ h_bound.choose_spec.2 N hN ] ;

/-
The sequence M tends to infinity.
-/
lemma M_tendsto_top : Filter.Tendsto M Filter.atTop Filter.atTop := by
  -- We'll use induction to show that $M_n$ grows exponentially.
  have h_exp_growth : ∀ n, M (n + 1) ≥ 2 * M n := by
    intro n;
    have h_M_succ : M (n + 1) ≥ M n * (2^(k n + 1) - 3) / 2 := by
      exact?;
    -- Since $k_n \geq 4$, we have $2^{k_n + 1} - 3 \geq 2^5 - 3 = 32 - 3 = 29$.
    have h_exp : 2^(k n + 1) - 3 ≥ 29 := by
      exact le_tsub_of_add_le_left ( by linarith [ Nat.pow_le_pow_right ( by decide : 1 ≤ 2 ) ( show k n + 1 ≥ 5 by linarith [ show k n ≥ 4 by exact le_add_of_nonneg_right ( Nat.zero_le _ ) ] ) ] );
    exact le_trans ( Nat.le_div_iff_mul_le zero_lt_two |>.2 <| by nlinarith ) h_M_succ;
  -- By induction, we can show that $M_n \geq 2^n$ for all $n$.
  have h_lower_bound : ∀ n, M n ≥ 2 ^ n := by
    exact fun n => Nat.recOn n ( by norm_num [ show M 0 = 10 by rfl ] ) fun n ih => by rw [ pow_succ' ] ; linarith [ h_exp_growth n ] ;
  exact Filter.tendsto_atTop_mono h_lower_bound ( Nat.tendsto_pow_atTop_atTop_of_one_lt one_lt_two )

/-
The count of exceptions up to m is bounded by E_N if m is small enough.
-/
def bad_count (n_0 m : ℕ) : ℕ := ((Finset.range m).filter (fun x => x ∉ P_T n_0)).card

lemma bad_count_le_E_N (n_0 N m : ℕ) (h_le : m ≤ M (N + 1) + 1) :
  bad_count n_0 m ≤ E_N n_0 N := by
    apply_rules [ Finset.card_le_card ];
    exact fun x hx => Finset.mem_filter.mpr ⟨ Finset.mem_range.mpr ( lt_of_lt_of_le ( Finset.mem_range.mp ( Finset.mem_filter.mp hx |>.1 ) ) h_le ), Finset.mem_filter.mp hx |>.2 ⟩

/-
We define N_of m and prove its basic properties.
-/
lemma exists_N_of (m : ℕ) : ∃ k, m ≤ M (k + 1) := by
  obtain ⟨k, hk⟩ := Filter.tendsto_atTop_atTop.mp M_tendsto_top m
  use k
  exact le_trans (hk k (le_refl k)) (M_mono (Nat.le_succ k))

noncomputable def N_of (m : ℕ) : ℕ := Nat.find (exists_N_of m)

lemma N_of_spec (m : ℕ) : m ≤ M (N_of m + 1) := Nat.find_spec (exists_N_of m)

lemma N_of_min (m k : ℕ) (h : k < N_of m) : M (k + 1) < m := by
  have := Nat.find_min (exists_N_of m) h
  push_neg at this
  exact this

/-
N_of is monotone.
-/
lemma N_of_mono : Monotone N_of := by
  -- If $m_1 \le m_2$, then the set of $k$ such that $m_2 \le M_{k+1}$ is a subset of the set of $k$ such that $m_1 \le M_{k+1}$.
  intros m1 m2 h_le
  apply Nat.find_mono;
  exact fun n hn => le_trans h_le hn

/-
N_of tends to infinity.
-/
lemma N_of_tendsto_atTop : Filter.Tendsto N_of Filter.atTop Filter.atTop := by
  refine' Filter.tendsto_atTop_atTop.mpr fun x => _;
  use M ( x + 1 ) + 1;
  -- By definition of $N_of$, we know that $N_of a$ is the smallest $k$ such that $a \leq M (k + 1)$.
  intros a ha
  have h_le : a ≤ M (N_of a + 1) := by
    exact Nat.find_spec ( exists_N_of a );
  -- By contradiction, assume $N_of a < x$.
  by_contra h_contra;
  exact h_le.not_lt <| lt_of_le_of_lt ( M_mono <| by linarith ) ha

/-
N_of tends to infinity.
-/
lemma N_of_tendsto_atTop_proven : Filter.Tendsto N_of Filter.atTop Filter.atTop := by
  rw [Filter.tendsto_atTop_atTop]
  intro b
  use M (b + 1) + 1
  intro n hn
  by_contra h_lt
  push_neg at h_lt
  have h_le : N_of n + 1 ≤ b := Nat.succ_le_of_lt h_lt
  have h_M_le : M (N_of n + 1) ≤ M b := M_mono h_le
  have h_n_le : n ≤ M (N_of n + 1) := N_of_spec n
  have h_n_le_Mb : n ≤ M b := le_trans h_n_le h_M_le
  have h_Mb_lt_n : M b < n := by
    calc M b ≤ M (b + 1) := M_mono (Nat.le_succ b)
         _   < M (b + 1) + 1 := Nat.lt_succ_self _
         _   ≤ n := hn
  linarith

/-
The density of the bad set tends to 0.
-/
lemma bad_density_tendsto_zero (n_0 : ℕ) :
  Filter.Tendsto (fun m => (bad_count n_0 m : ℝ) / m) Filter.atTop (nhds 0) := by
    -- For m > M 1, N_of m >= 1.
    have h_N_of_ge_1 : ∀ᶠ m in Filter.atTop, 1 ≤ N_of m := by
      have h_N_of_ge_1 : ∀ᶠ m in Filter.atTop, m > M 1 := by
        exact Filter.eventually_gt_atTop _;
      filter_upwards [ h_N_of_ge_1 ] with m hm;
      exact Nat.pos_of_ne_zero fun h => hm.not_le <| by have := N_of_spec m; aesop;
    -- For m > M 1, N_of m >= 1. By N_of_min, M (N_of m) < m.
    have h_bound : ∀ᶠ m in Filter.atTop, (bad_count n_0 m : ℝ) / m ≤ (E_N n_0 (N_of m) : ℝ) / M (N_of m) := by
      have h_bound : ∀ᶠ m in Filter.atTop, (bad_count n_0 m : ℝ) ≤ E_N n_0 (N_of m) := by
        filter_upwards [ h_N_of_ge_1, Filter.eventually_gt_atTop 0 ] with m hm₁ hm₂ using mod_cast by simpa using bad_count_le_E_N n_0 ( N_of m ) m ( by linarith [ N_of_spec m ] ) ;
      have h_bound : ∀ᶠ m in Filter.atTop, (M (N_of m) : ℝ) < m := by
        filter_upwards [ h_N_of_ge_1, Filter.eventually_gt_atTop ( M 1 ) ] with m hm₁ hm₂;
        have := N_of_min m ( N_of m - 1 ) ; rcases k : N_of m with ( _ | _ | k ) <;> aesop;
      filter_upwards [ h_bound, ‹∀ᶠ m in Filter.atTop, ( bad_count n_0 m : ℝ ) ≤ E_N n_0 ( N_of m ) › ] with m hm₁ hm₂ using by rw [ div_le_div_iff₀ ] <;> nlinarith [ show ( M ( N_of m ) : ℝ ) > 0 from Nat.cast_pos.mpr ( M_pos _ ) ] ;
    refine' squeeze_zero_norm' _ _;
    use fun m => ( E_N n_0 ( N_of m ) : ℝ ) / M ( N_of m );
    · filter_upwards [ h_bound ] with m hm using by rw [ Real.norm_of_nonneg ( by positivity ) ] ; exact hm;
    · exact Filter.Tendsto.comp ( density_ratio_lower_tendsto_zero n_0 ) ( N_of_tendsto_atTop )

/-
P(T) has asymptotic density 1.
-/
lemma P_T_density_one (n_0 : ℕ) : has_asymptotic_density_one (P_T n_0) := by
  unfold has_asymptotic_density_one;
  -- The density is 1 - bad_density. Since bad_density tends to 0, density tends to 1.
  have h_density : Filter.Tendsto (fun n => 1 - (bad_count n_0 n : ℝ) / n) Filter.atTop (nhds 1) := by
    simpa using tendsto_const_nhds.sub ( bad_density_tendsto_zero n_0 );
  -- The cardinality of the set of elements in P_T up to n is equal to the cardinality of the range n minus the cardinality of the bad_count set.
  have h_card_eq : ∀ n, ((Finset.range n).filter (· ∈ P_T n_0)).card = n - bad_count n_0 n := by
    intros n
    simp [bad_count];
    rw [ Finset.filter_not, Finset.card_sdiff ] ; norm_num;
    rw [ Nat.sub_sub_self ];
    · exact congr_arg Finset.card ( by ext; aesop );
    · exact le_trans ( Finset.card_le_card ( Finset.inter_subset_right ) ) ( by simpa );
  refine' h_density.congr' _;
  filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn;
  rw [ h_card_eq, Nat.cast_sub ];
  · rw [ sub_div, div_self ( by positivity ) ];
  · exact le_trans ( Finset.card_filter_le _ _ ) ( by simpa )

/-
If a subset has density 1, the superset has density 1.
-/
lemma density_superset {S1 S2 : Set ℕ} (h : S1 ⊆ S2) (h_dens : has_asymptotic_density_one S1) :
  has_asymptotic_density_one S2 := by
    -- Since $S1 \subseteq S2$, the count of elements in $S1 \cap \{0, \ldots, n-1\}$ is less than or equal to the count in $S2 \cap \{0, \ldots, n-1\}$.
    have h_ratio_le : ∀ n, ((Finset.range n).filter (· ∈ S1)).card ≤ ((Finset.range n).filter (· ∈ S2)).card := by
      exact fun n => Finset.card_mono fun x hx => by aesop;
    have h_ratio_ge : Filter.Tendsto (fun n => ((Finset.range n).filter (· ∈ S2)).card / (n : ℝ)) Filter.atTop (nhds 1) := by
      have h_lim_inf : Filter.Tendsto (fun n => ((Finset.range n).filter (· ∈ S1)).card / (n : ℝ)) Filter.atTop (nhds 1) := h_dens
      refine' tendsto_of_tendsto_of_tendsto_of_le_of_le' h_lim_inf tendsto_const_nhds _ _;
      · filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn using div_le_div_of_nonneg_right ( mod_cast h_ratio_le n ) ( Nat.cast_nonneg _ );
      · filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn using div_le_one_of_le₀ ( mod_cast le_trans ( Finset.card_filter_le _ _ ) ( by simpa ) ) ( by positivity );
    exact h_ratio_ge

/-
We define subset sums for sets and prove monotonicity.
-/
def subset_sums_of_set (S : Set ℕ) : Set ℕ :=
  {s | ∃ (B : Finset ℕ), (∀ x ∈ B, x ∈ S) ∧ s = B.sum id}

lemma subset_sums_mono {S1 S2 : Set ℕ} (h : S1 ⊆ S2) :
  subset_sums_of_set S1 ⊆ subset_sums_of_set S2 := by
    intro s hs;
    unfold subset_sums_of_set at hs ⊢; aesop;

/-
P(T) has asymptotic density 1.
-/
lemma P_T_density_one_proven (n_0 : ℕ) : has_asymptotic_density_one (P_T n_0) := by
  unfold has_asymptotic_density_one;
  -- The density is 1 - bad_density. Since bad_density tends to 0, density tends to 1.
  have h_density : Filter.Tendsto (fun n => 1 - (bad_count n_0 n : ℝ) / n) Filter.atTop (nhds 1) := by
    simpa using tendsto_const_nhds.sub ( bad_density_tendsto_zero n_0 );
  -- The cardinality of the set of elements in P_T up to n is equal to the cardinality of the range n minus the cardinality of the bad_count set.
  have h_card_eq : ∀ n, ((Finset.range n).filter (· ∈ P_T n_0)).card = n - bad_count n_0 n := by
    intros n
    simp [bad_count];
    rw [ Finset.filter_not, Finset.card_sdiff ] ; norm_num;
    rw [ Nat.sub_sub_self ];
    · exact congr_arg Finset.card ( by ext; aesop );
    · exact le_trans ( Finset.card_le_card ( Finset.inter_subset_right ) ) ( by simpa );
  refine' h_density.congr' _;
  filter_upwards [ Filter.eventually_gt_atTop 0 ] with n hn;
  rw [ h_card_eq, Nat.cast_sub ];
  · rw [ sub_div, div_self ( by positivity ) ];
  · exact le_trans ( Finset.card_filter_le _ _ ) ( by simpa )

/-
The last element of block n is strictly less than the first element of block n+1.
-/
lemma M_transition_strict_ineq (n : ℕ) : (2^(k n - 1) - 1) * M n + 1 < M (n + 1) := by
  -- We know that $k_n \geq 4$, which implies $2^{k_n - 1} \geq 8$.
  have h_exp : 2^(k n - 1) ≥ 8 := by
    exact le_trans ( by decide ) ( pow_le_pow_right₀ ( by decide ) ( Nat.sub_le_sub_right ( show k n ≥ 4 by exact Nat.le_add_right _ _ ) _ ) );
  have h_floor : (M (n + 1) : ℝ) ≥ (M n : ℝ) * (2^(k n) - 3 / 2 : ℝ) - 1 := by
    convert M_recurrence_ineq n using 1;
    unfold product_term a_seq; ring;
    rw [ show B_card n = 2 ^ k n - 1 from B_card_eq n ] ; rw [ Nat.cast_sub ( Nat.one_le_pow _ _ ( by decide ) ) ] ; push_cast ; ring;
  rcases hk : k n with ( _ | _ | _ | _ | k ) <;> simp_all +decide [ pow_succ' ] ; ring_nf at * ; norm_num at *;
  rw [ ← @Nat.cast_lt ℝ ] ; norm_num ; nlinarith [ show ( 1 : ℝ ) ≤ 2 ^ k by exact_mod_cast h_exp, show ( M n : ℝ ) ≥ 1 by exact_mod_cast Nat.one_le_iff_ne_zero.mpr <| ne_of_gt <| M_pos n ] ;

/-
Each block is strictly sorted.
-/
lemma block_strict_sorted (n : ℕ) : (block n).Sorted (· < ·) := by
  -- The list [2^i * M n | i < k n - 1] is strictly increasing because each term is twice the previous term.
  have h_increasing : StrictMono (fun i => 2^i * M n : ℕ → ℕ) := by
    exact fun i j hij => mul_lt_mul_of_pos_right ( pow_lt_pow_right₀ ( by decide ) hij ) ( M_pos n );
  -- The second part of the list, which is [(2^(k n - 1) - 1) * M n + 1], is a single element and thus trivially sorted.
  have h_second_part : (2^(k n - 1) - 1) * M n + 1 > 2^(k n - 2) * M n := by
    rcases k : k n with ( _ | _ | k ) <;> simp_all +decide [ pow_succ' ];
    · unfold _root_.k at k; aesop;
    · unfold _root_.k at k;
      omega;
    · nlinarith [ Nat.sub_add_cancel ( show 0 < 2 * 2 ^ ‹_› from by positivity ), pow_pos ( show 0 < 2 by decide ) ‹_›, M_pos n ];
  unfold block;
  rw [ List.Sorted ];
  rcases k : k n with ( _ | _ | k ) <;> simp_all +decide [ List.pairwise_append, List.pairwise_map ];
  exact ⟨ List.pairwise_iff_get.mpr fun i j hij => h_increasing ( by simpa using hij ), fun a ha => lt_of_le_of_lt ( h_increasing.monotone ( Nat.le_of_lt_succ ha ) ) h_second_part ⟩

/-
The block index increases by at most 1 at each step.
-/
lemma block_index_succ (n : ℕ) :
  block_index (n + 1) = block_index n ∨ block_index (n + 1) = block_index n + 1 := by
    have h_block_index : block_start (block_index n) ≤ n + 1 ∧ n + 1 < block_start (block_index n + 2) := by
      have := block_index_spec n;
      exact ⟨ by linarith, by linarith [ this.2, block_start_strict_mono ( Nat.lt_succ_self ( block_index n + 1 ) ) ] ⟩;
    have h_block_index : block_index (n + 1) ≤ block_index n + 1 := by
      exact Nat.find_min' _ h_block_index.2;
    have h_block_index : block_index n ≤ block_index (n + 1) := by
      apply Nat.le_of_not_lt; intro h_contra;
      have h_block_index : block_start (block_index (n + 1) + 1) ≤ block_start (block_index n) := by
        exact monotone_nat_of_le_succ ( fun n => by exact Nat.le_add_right _ _ ) ( by linarith );
      linarith [ block_index_spec ( n + 1 ) ];
    omega

/-
A_val n is strictly less than A_val (n+1).
-/
lemma A_lt_succ (n : ℕ) : A_val n < A_val (n + 1) := by
  have h_block_index : block_index (n + 1) = block_index n ∨ block_index (n + 1) = block_index n + 1 := by
    exact?;
  cases' h_block_index with h h;
  · -- Since $n$ and $n+1$ are in the same block, we can use the strict monotonicity of the block.
    have h_block_mono : (block (block_index n)).get! (n - block_start (block_index n)) < (block (block_index n)).get! (n + 1 - block_start (block_index n)) := by
      have h_block_mono : ∀ i j, i < j → i < (block (block_index n)).length → j < (block (block_index n)).length → (block (block_index n)).get! i < (block (block_index n)).get! j := by
        intros i j hij hi hj;
        have := List.pairwise_iff_get.mp ( block_strict_sorted ( block_index n ) );
        simpa [ List.get?_eq_get, hi, hj ] using this ⟨ i, hi ⟩ ⟨ j, hj ⟩ hij;
      apply h_block_mono;
      · rw [ tsub_lt_tsub_iff_right ] <;> linarith [ block_index_spec n ];
      · have := block_index_spec n;
        rw [ tsub_lt_iff_left ] <;> aesop;
      · rw [ tsub_lt_iff_left ];
        · have := block_index_spec ( n + 1 ) ; aesop;
        · exact Nat.le_succ_of_le ( block_index_spec n |>.1 );
    unfold A_val;
    unfold block_index at * ; aesop;
  · -- By definition of A_val, we know that A_val n is the last element of block (block_index n) and A_val (n + 1) is the first element of block (block_index n + 1).
    have h_A_val_def : A_val n = (2^(k (block_index n) - 1) - 1) * M (block_index n) + 1 ∧ A_val (n + 1) = M (block_index n + 1) := by
      have h_A_val_def : A_val n = (block (block_index n)).get! ((block (block_index n)).length - 1) ∧ A_val (n + 1) = (block (block_index n + 1)).get! 0 := by
        have h_block_index_n : block_start (block_index n) ≤ n ∧ n < block_start (block_index n + 1) := by
          apply block_index_spec
        have h_block_index_n1 : block_start (block_index n + 1) ≤ n + 1 ∧ n + 1 < block_start (block_index n + 2) := by
          have := block_index_spec ( n + 1 ) ; aesop;
        have h_A_val_def : A_val n = (block (block_index n)).get! (n - block_start (block_index n)) ∧ A_val (n + 1) = (block (block_index n + 1)).get! ((n + 1) - block_start (block_index n + 1)) := by
          exact ⟨ rfl, by rw [ ← h ] ; rfl ⟩;
        have h_block_length : ∀ n, block_start (n + 1) = block_start n + (block n).length := by
          exact?;
        grind;
      simp_all +decide [ block ];
      rcases x : k ( block_index n + 1 ) with ( _ | _ | k ) <;> simp_all +decide [ List.range_succ_eq_map ];
      · unfold k at x; aesop;
      · unfold k at x;
        grind;
    exact h_A_val_def.1.symm ▸ h_A_val_def.2.symm ▸ M_transition_strict_ineq _

/-
If S is a cofinite subsequence, it contains the tail of the sequence starting from some block.
-/
def range_A : Set ℕ := Set.range A_val

def is_cofinite_subsequence (S : Set ℕ) : Prop := S ⊆ range_A ∧ (range_A \ S).Finite

lemma T_seq_range_subset (S : Set ℕ) (h : is_cofinite_subsequence S) :
  ∃ n_0, Set.range (T_seq n_0) ⊆ S := by
    -- Since $range\_A \setminus S$ is finite, there exists $k$ such that $A_k \notin S$ and for all $i > k$, $A_i \in S$.
    obtain ⟨k, hk⟩ : ∃ k, ∀ i > k, A_val i ∈ S := by
      cases' h with k hk;
      contrapose! hk;
      exact Set.infinite_of_forall_exists_gt fun n => by obtain ⟨ m, hm₁, hm₂ ⟩ := hk n; exact ⟨ A_val m, ⟨ ⟨ m, rfl ⟩, hm₂ ⟩, by linarith [ show A_val m ≥ m from Nat.recOn m ( by norm_num [ A_val ] ) fun n ihn => by linarith [ A_lt_succ n ] ] ⟩ ;
    use k + 1;
    rintro x ⟨ i, rfl ⟩;
    convert hk ( block_start ( k + 1 ) + i ) ( by linarith [ show block_start ( k + 1 ) ≥ k + 1 from Nat.recOn ( k + 1 ) ( by norm_num ) fun n ihn => by linarith [ show block_start ( n + 1 ) ≥ block_start n + 1 from Nat.succ_le_of_lt ( by { exact lt_of_lt_of_le ( by { exact Nat.lt_succ_self _ } ) ( show block_start n + 1 ≤ block_start ( n + 1 ) from by { rw [ show block_start ( n + 1 ) = block_start n + ( block n |> List.length ) from rfl ] ; exact Nat.succ_le_of_lt ( Nat.lt_add_of_pos_right ( block_length_pos _ ) ) } ) } ) ] ] ) using 1

/-
The sequence A is strictly increasing.
-/
lemma A_strict_mono_proven : StrictMono A_val := by
  apply strictMono_nat_of_lt_succ
  exact A_lt_succ

/-
T_seq is strictly increasing.
-/
lemma T_seq_strict_mono (n_0 : ℕ) : StrictMono (T_seq n_0) := by
  intro i j hij
  unfold T_seq
  apply A_strict_mono_proven
  simp
  exact hij

/-
If f is injective, subset_sums f equals subset_sums_of_set (range f).
-/
lemma subset_sums_eq_subset_sums_of_set_of_injective {f : ℕ → ℕ} (h_inj : Function.Injective f) :
  subset_sums f = subset_sums_of_set (Set.range f) := by
    -- To prove equality of sets, we show each set is a subset of the other.
    apply Set.ext
    intro s
    simp [subset_sums, subset_sums_of_set];
    constructor;
    · simp +zetaDelta at *;
      exact fun x hx => ⟨ x.image f, fun y hy => by aesop, by simpa [ Finset.sum_image, h_inj.eq_iff ] using hx ⟩;
    · rintro ⟨ B, hB₁, rfl ⟩;
      choose! g hg using hB₁;
      use Finset.image g B; rw [ Finset.sum_image <| by intros x hx y hy hxy; have := hg x hx; have := hg y hy; aesop ] ; aesop;

/-
The set of subset sums of any cofinite subsequence has asymptotic density 1.
-/
theorem main_theorem (S : Set ℕ) (h : is_cofinite_subsequence S) :
  has_asymptotic_density_one (subset_sums_of_set S) := by
  obtain ⟨n_0, h_subset⟩ := T_seq_range_subset S h
  have h_inj : Function.Injective (T_seq n_0) := StrictMono.injective (T_seq_strict_mono n_0)
  have h_eq : subset_sums (T_seq n_0) = subset_sums_of_set (Set.range (T_seq n_0)) :=
    subset_sums_eq_subset_sums_of_set_of_injective h_inj
  have h_sub : subset_sums (T_seq n_0) ⊆ subset_sums_of_set S := by
    rw [h_eq]
    exact subset_sums_mono h_subset
  have h_dens : has_asymptotic_density_one (subset_sums (T_seq n_0)) := P_T_density_one n_0
  exact density_superset h_sub h_dens

/-
There exists a sequence A satisfying the required properties.
-/
theorem answer_is_yes : ∃ A : ℕ → ℕ, Monotone A ∧ (Filter.Tendsto (fun n => (A (n + 1) : ℝ) / A n) Filter.atTop (nhds 2)) ∧ (∀ S, S ⊆ Set.range A ∧ (Set.range A \ S).Finite → has_asymptotic_density_one (subset_sums_of_set S)) := by
  use A_val
  refine ⟨A_is_nondecreasing, A_ratio_limit, ?_⟩
  intro S hS
  exact main_theorem S hS
